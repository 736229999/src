/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "opencai.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public extension Apiproto{}

public extension Apiproto {
    public struct OpencaiRoot {
        public static let `default` = OpencaiRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    public enum LotteryType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case allType = 0

        /// 低频彩
        case lowFreq = 1

        /// 高频彩
        case highFreq = 2

        /// 竞彩
        case comp = 3
        public func toString() -> String {
            switch self {
            case .allType: return "AllType"
            case .lowFreq: return "LowFreq"
            case .highFreq: return "HighFreq"
            case .comp: return "Comp"
            }
        }
        public static func fromString(str:String) throws -> Apiproto.LotteryType {
            switch str {
            case "AllType":    return .allType
            case "LowFreq":    return .lowFreq
            case "HighFreq":    return .highFreq
            case "Comp":    return .comp
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .allType: return ".allType"
            case .lowFreq: return ".lowFreq"
            case .highFreq: return ".highFreq"
            case .comp: return ".comp"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:LotteryType, rhs:LotteryType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum LotteryId:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case allId = 0

        /// 大乐透
        case dlt = 1

        /// 福彩3D
        case fc3D = 2

        /// 双色球
        case ssq = 3

        /// 重庆时时彩
        case cqssc = 4

        /// 北京PK拾
        case bjpk10 = 5

        /// 广东11选5
        case gd11X5 = 6

        /// 排列三
        case pl3 = 7

        /// 排列五
        case pl5 = 8

        ///竞彩足球
        case jczq = 9

        ///竞彩篮球
        case jclq = 10
        public func toString() -> String {
            switch self {
            case .allId: return "AllId"
            case .dlt: return "Dlt"
            case .fc3D: return "Fc3d"
            case .ssq: return "Ssq"
            case .cqssc: return "Cqssc"
            case .bjpk10: return "Bjpk10"
            case .gd11X5: return "Gd11x5"
            case .pl3: return "Pl3"
            case .pl5: return "Pl5"
            case .jczq: return "Jczq"
            case .jclq: return "Jclq"
            }
        }
        public static func fromString(str:String) throws -> Apiproto.LotteryId {
            switch str {
            case "AllId":    return .allId
            case "Dlt":    return .dlt
            case "Fc3d":    return .fc3D
            case "Ssq":    return .ssq
            case "Cqssc":    return .cqssc
            case "Bjpk10":    return .bjpk10
            case "Gd11x5":    return .gd11X5
            case "Pl3":    return .pl3
            case "Pl5":    return .pl5
            case "Jczq":    return .jczq
            case "Jclq":    return .jclq
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .allId: return ".allId"
            case .dlt: return ".dlt"
            case .fc3D: return ".fc3D"
            case .ssq: return ".ssq"
            case .cqssc: return ".cqssc"
            case .bjpk10: return ".bjpk10"
            case .gd11X5: return ".gd11X5"
            case .pl3: return ".pl3"
            case .pl5: return ".pl5"
            case .jczq: return ".jczq"
            case .jclq: return ".jclq"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:LotteryId, rhs:LotteryId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    final public class BonusDetail : GeneratedMessage {

        public static func == (lhs: Apiproto.BonusDetail, rhs: Apiproto.BonusDetail) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasNum == rhs.hasNum) && (!lhs.hasNum || lhs.num == rhs.num)
            fieldCheck = fieldCheck && (lhs.hasMoney == rhs.hasMoney) && (!lhs.hasMoney || lhs.money == rhs.money)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var num:Int32 = Int32(0)
        public fileprivate(set) var hasNum:Bool = false

        public fileprivate(set) var money:Double = Double(0)
        public fileprivate(set) var hasMoney:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasNum {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:num)
            }
            if hasMoney {
                try codedOutputStream.writeDouble(fieldNumber: 3, value:money)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasNum {
                serialize_size += num.computeInt32Size(fieldNumber: 2)
            }
            if hasMoney {
                serialize_size += money.computeDoubleSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.BonusDetail.Builder {
            return Apiproto.BonusDetail.classBuilder() as! Apiproto.BonusDetail.Builder
        }
        public func getBuilder() -> Apiproto.BonusDetail.Builder {
            return classBuilder() as! Apiproto.BonusDetail.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.BonusDetail.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.BonusDetail.Builder()
        }
        public func toBuilder() throws -> Apiproto.BonusDetail.Builder {
            return try Apiproto.BonusDetail.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.BonusDetail) throws -> Apiproto.BonusDetail.Builder {
            return try Apiproto.BonusDetail.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasNum {
                jsonMap["num"] = Int(num)
            }
            if hasMoney {
                jsonMap["money"] = Double(money)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.BonusDetail {
            return try Apiproto.BonusDetail.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.BonusDetail {
            return try Apiproto.BonusDetail.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasNum {
                output += "\(indent) num: \(num) \n"
            }
            if hasMoney {
                output += "\(indent) money: \(money) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasNum {
                    hashCode = (hashCode &* 31) &+ num.hashValue
                }
                if hasMoney {
                    hashCode = (hashCode &* 31) &+ money.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.BonusDetail"
        }
        override public func className() -> String {
            return "Apiproto.BonusDetail"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.BonusDetail = Apiproto.BonusDetail()
            public func getMessage() -> Apiproto.BonusDetail {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Apiproto.BonusDetail.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Apiproto.BonusDetail.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            public var num:Int32 {
                get {
                    return builderResult.num
                }
                set (value) {
                    builderResult.hasNum = true
                    builderResult.num = value
                }
            }
            public var hasNum:Bool {
                get {
                    return builderResult.hasNum
                }
            }
            @discardableResult
            public func setNum(_ value:Int32) -> Apiproto.BonusDetail.Builder {
                self.num = value
                return self
            }
            @discardableResult
            public func clearNum() -> Apiproto.BonusDetail.Builder{
                builderResult.hasNum = false
                builderResult.num = Int32(0)
                return self
            }
            public var money:Double {
                get {
                    return builderResult.money
                }
                set (value) {
                    builderResult.hasMoney = true
                    builderResult.money = value
                }
            }
            public var hasMoney:Bool {
                get {
                    return builderResult.hasMoney
                }
            }
            @discardableResult
            public func setMoney(_ value:Double) -> Apiproto.BonusDetail.Builder {
                self.money = value
                return self
            }
            @discardableResult
            public func clearMoney() -> Apiproto.BonusDetail.Builder{
                builderResult.hasMoney = false
                builderResult.money = Double(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.BonusDetail.Builder {
                builderResult = Apiproto.BonusDetail()
                return self
            }
            override public func clone() throws -> Apiproto.BonusDetail.Builder {
                return try Apiproto.BonusDetail.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.BonusDetail {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.BonusDetail {
                let returnMe:Apiproto.BonusDetail = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.BonusDetail) throws -> Apiproto.BonusDetail.Builder {
                if other == Apiproto.BonusDetail() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasNum {
                    num = other.num
                }
                if other.hasMoney {
                    money = other.money
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.BonusDetail.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.BonusDetail.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 16:
                        num = try codedInputStream.readInt32()

                    case 25:
                        money = try codedInputStream.readDouble()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.BonusDetail.Builder {
                let resultDecodedBuilder = Apiproto.BonusDetail.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueNum = jsonMap["num"] as? Int {
                    resultDecodedBuilder.num = Int32(jsonValueNum)
                } else if let jsonValueNum = jsonMap["num"] as? String {
                    resultDecodedBuilder.num = Int32(jsonValueNum)!
                }
                if let jsonValueMoney = jsonMap["money"] as? Double {
                    resultDecodedBuilder.money = Double(jsonValueMoney)
                } else if let jsonValueMoney = jsonMap["money"] as? String {
                    resultDecodedBuilder.money = Double(jsonValueMoney)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.BonusDetail.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.BonusDetail.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// 开奖详细
    final public class OpenDetail : GeneratedMessage {

        public static func == (lhs: Apiproto.OpenDetail, rhs: Apiproto.OpenDetail) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSale == rhs.hasSale) && (!lhs.hasSale || lhs.sale == rhs.sale)
            fieldCheck = fieldCheck && (lhs.hasPool == rhs.hasPool) && (!lhs.hasPool || lhs.pool == rhs.pool)
            fieldCheck = fieldCheck && (lhs.bonusList == rhs.bonusList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// 本期销售额
        public fileprivate(set) var sale:Double = Double(0)
        public fileprivate(set) var hasSale:Bool = false

        /// 奖池
        public fileprivate(set) var pool:Double = Double(0)
        public fileprivate(set) var hasPool:Bool = false

        public fileprivate(set) var bonusList:Array<Apiproto.BonusDetail>  = Array<Apiproto.BonusDetail>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSale {
                try codedOutputStream.writeDouble(fieldNumber: 1, value:sale)
            }
            if hasPool {
                try codedOutputStream.writeDouble(fieldNumber: 2, value:pool)
            }
            for oneElementBonusList in bonusList {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementBonusList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSale {
                serialize_size += sale.computeDoubleSize(fieldNumber: 1)
            }
            if hasPool {
                serialize_size += pool.computeDoubleSize(fieldNumber: 2)
            }
            for oneElementBonusList in bonusList {
                serialize_size += oneElementBonusList.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.OpenDetail.Builder {
            return Apiproto.OpenDetail.classBuilder() as! Apiproto.OpenDetail.Builder
        }
        public func getBuilder() -> Apiproto.OpenDetail.Builder {
            return classBuilder() as! Apiproto.OpenDetail.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.OpenDetail.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.OpenDetail.Builder()
        }
        public func toBuilder() throws -> Apiproto.OpenDetail.Builder {
            return try Apiproto.OpenDetail.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.OpenDetail) throws -> Apiproto.OpenDetail.Builder {
            return try Apiproto.OpenDetail.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSale {
                jsonMap["sale"] = Double(sale)
            }
            if hasPool {
                jsonMap["pool"] = Double(pool)
            }
            if !bonusList.isEmpty {
                var jsonArrayBonusList:Array<Dictionary<String,Any>> = []
                for oneValueBonusList in bonusList {
                    let ecodedMessageBonusList = try oneValueBonusList.encode()
                    jsonArrayBonusList.append(ecodedMessageBonusList)
                }
                jsonMap["bonusList"] = jsonArrayBonusList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.OpenDetail {
            return try Apiproto.OpenDetail.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.OpenDetail {
            return try Apiproto.OpenDetail.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSale {
                output += "\(indent) sale: \(sale) \n"
            }
            if hasPool {
                output += "\(indent) pool: \(pool) \n"
            }
            var bonusListElementIndex:Int = 0
            for oneElementBonusList in bonusList {
                output += "\(indent) bonusList[\(bonusListElementIndex)] {\n"
                output += try oneElementBonusList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                bonusListElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSale {
                    hashCode = (hashCode &* 31) &+ sale.hashValue
                }
                if hasPool {
                    hashCode = (hashCode &* 31) &+ pool.hashValue
                }
                for oneElementBonusList in bonusList {
                    hashCode = (hashCode &* 31) &+ oneElementBonusList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.OpenDetail"
        }
        override public func className() -> String {
            return "Apiproto.OpenDetail"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.OpenDetail = Apiproto.OpenDetail()
            public func getMessage() -> Apiproto.OpenDetail {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// 本期销售额
            public var sale:Double {
                get {
                    return builderResult.sale
                }
                set (value) {
                    builderResult.hasSale = true
                    builderResult.sale = value
                }
            }
            public var hasSale:Bool {
                get {
                    return builderResult.hasSale
                }
            }
            @discardableResult
            public func setSale(_ value:Double) -> Apiproto.OpenDetail.Builder {
                self.sale = value
                return self
            }
            @discardableResult
            public func clearSale() -> Apiproto.OpenDetail.Builder{
                builderResult.hasSale = false
                builderResult.sale = Double(0)
                return self
            }
            /// 奖池
            public var pool:Double {
                get {
                    return builderResult.pool
                }
                set (value) {
                    builderResult.hasPool = true
                    builderResult.pool = value
                }
            }
            public var hasPool:Bool {
                get {
                    return builderResult.hasPool
                }
            }
            @discardableResult
            public func setPool(_ value:Double) -> Apiproto.OpenDetail.Builder {
                self.pool = value
                return self
            }
            @discardableResult
            public func clearPool() -> Apiproto.OpenDetail.Builder{
                builderResult.hasPool = false
                builderResult.pool = Double(0)
                return self
            }
            /// 中奖详情
            public var bonusList:Array<Apiproto.BonusDetail> {
                get {
                    return builderResult.bonusList
                }
                set (value) {
                    builderResult.bonusList = value
                }
            }
            @discardableResult
            public func setBonusList(_ value:Array<Apiproto.BonusDetail>) -> Apiproto.OpenDetail.Builder {
                self.bonusList = value
                return self
            }
            @discardableResult
            public func clearBonusList() -> Apiproto.OpenDetail.Builder {
                builderResult.bonusList.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.OpenDetail.Builder {
                builderResult = Apiproto.OpenDetail()
                return self
            }
            override public func clone() throws -> Apiproto.OpenDetail.Builder {
                return try Apiproto.OpenDetail.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.OpenDetail {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.OpenDetail {
                let returnMe:Apiproto.OpenDetail = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.OpenDetail) throws -> Apiproto.OpenDetail.Builder {
                if other == Apiproto.OpenDetail() {
                    return self
                }
                if other.hasSale {
                    sale = other.sale
                }
                if other.hasPool {
                    pool = other.pool
                }
                if !other.bonusList.isEmpty  {
                     builderResult.bonusList += other.bonusList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.OpenDetail.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenDetail.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 9:
                        sale = try codedInputStream.readDouble()

                    case 17:
                        pool = try codedInputStream.readDouble()

                    case 26:
                        let subBuilder = Apiproto.BonusDetail.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        bonusList.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.OpenDetail.Builder {
                let resultDecodedBuilder = Apiproto.OpenDetail.Builder()
                if let jsonValueSale = jsonMap["sale"] as? Double {
                    resultDecodedBuilder.sale = Double(jsonValueSale)
                } else if let jsonValueSale = jsonMap["sale"] as? String {
                    resultDecodedBuilder.sale = Double(jsonValueSale)!
                }
                if let jsonValuePool = jsonMap["pool"] as? Double {
                    resultDecodedBuilder.pool = Double(jsonValuePool)
                } else if let jsonValuePool = jsonMap["pool"] as? String {
                    resultDecodedBuilder.pool = Double(jsonValuePool)!
                }
                if let jsonValueBonusList = jsonMap["bonusList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayBonusList:Array<Apiproto.BonusDetail> = []
                    for oneValueBonusList in jsonValueBonusList {
                        let messageFromStringBonusList = try Apiproto.BonusDetail.Builder.decodeToBuilder(jsonMap:oneValueBonusList).build()

                        jsonArrayBonusList.append(messageFromStringBonusList)
                    }
                    resultDecodedBuilder.bonusList = jsonArrayBonusList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.OpenDetail.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.OpenDetail.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OpenInfo : GeneratedMessage {

        public static func == (lhs: Apiproto.OpenInfo, rhs: Apiproto.OpenInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasIssue == rhs.hasIssue) && (!lhs.hasIssue || lhs.issue == rhs.issue)
            fieldCheck = fieldCheck && (lhs.hasNo == rhs.hasNo) && (!lhs.hasNo || lhs.no == rhs.no)
            fieldCheck = fieldCheck && (lhs.hasOpenTime == rhs.hasOpenTime) && (!lhs.hasOpenTime || lhs.openTime == rhs.openTime)
            fieldCheck = fieldCheck && (lhs.balls == rhs.balls)
            fieldCheck = fieldCheck && (lhs.hasBlueNum == rhs.hasBlueNum) && (!lhs.hasBlueNum || lhs.blueNum == rhs.blueNum)
            fieldCheck = fieldCheck && (lhs.hasDetail == rhs.hasDetail) && (!lhs.hasDetail || lhs.detail == rhs.detail)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var type:Apiproto.LotteryType = Apiproto.LotteryType.allType
        public fileprivate(set) var hasType:Bool = false
        public fileprivate(set) var id:Apiproto.LotteryId = Apiproto.LotteryId.allId
        public fileprivate(set) var hasId:Bool = false
        /// 彩种名字
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// 期号
        public fileprivate(set) var issue:String = ""
        public fileprivate(set) var hasIssue:Bool = false

        /// 当日期号(高频彩使用)
        public fileprivate(set) var no:Int32 = Int32(0)
        public fileprivate(set) var hasNo:Bool = false

        /// 开奖时间
        public fileprivate(set) var openTime:Int64 = Int64(0)
        public fileprivate(set) var hasOpenTime:Bool = false

        /// 开奖号码
        public fileprivate(set) var balls:Array<String> = Array<String>()
        /// 蓝球个数
        public fileprivate(set) var blueNum:Int32 = Int32(0)
        public fileprivate(set) var hasBlueNum:Bool = false

        public fileprivate(set) var detail:Apiproto.OpenDetail!
        public fileprivate(set) var hasDetail:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:type.rawValue)
            }
            if hasId {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:id.rawValue)
            }
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 3, value:name)
            }
            if hasIssue {
                try codedOutputStream.writeString(fieldNumber: 4, value:issue)
            }
            if hasNo {
                try codedOutputStream.writeInt32(fieldNumber: 5, value:no)
            }
            if hasOpenTime {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:openTime)
            }
            if !balls.isEmpty {
                for oneValueballs in balls {
                    try codedOutputStream.writeString(fieldNumber: 7, value:oneValueballs)
                }
            }
            if hasBlueNum {
                try codedOutputStream.writeInt32(fieldNumber: 8, value:blueNum)
            }
            if hasDetail {
                try codedOutputStream.writeMessage(fieldNumber: 9, value:detail)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if (hasId) {
                serialize_size += id.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 3)
            }
            if hasIssue {
                serialize_size += issue.computeStringSize(fieldNumber: 4)
            }
            if hasNo {
                serialize_size += no.computeInt32Size(fieldNumber: 5)
            }
            if hasOpenTime {
                serialize_size += openTime.computeInt64Size(fieldNumber: 6)
            }
            var dataSizeBalls:Int32 = 0
            for oneValueballs in balls {
                dataSizeBalls += oneValueballs.computeStringSizeNoTag()
            }
            serialize_size += dataSizeBalls
            serialize_size += 1 * Int32(balls.count)
            if hasBlueNum {
                serialize_size += blueNum.computeInt32Size(fieldNumber: 8)
            }
            if hasDetail {
                if let varSizedetail = detail?.computeMessageSize(fieldNumber: 9) {
                    serialize_size += varSizedetail
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.OpenInfo.Builder {
            return Apiproto.OpenInfo.classBuilder() as! Apiproto.OpenInfo.Builder
        }
        public func getBuilder() -> Apiproto.OpenInfo.Builder {
            return classBuilder() as! Apiproto.OpenInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.OpenInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.OpenInfo.Builder()
        }
        public func toBuilder() throws -> Apiproto.OpenInfo.Builder {
            return try Apiproto.OpenInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.OpenInfo) throws -> Apiproto.OpenInfo.Builder {
            return try Apiproto.OpenInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasType {
                jsonMap["type"] = type.toString()
            }
            if hasId {
                jsonMap["id"] = id.toString()
            }
            if hasName {
                jsonMap["name"] = name
            }
            if hasIssue {
                jsonMap["issue"] = issue
            }
            if hasNo {
                jsonMap["no"] = Int(no)
            }
            if hasOpenTime {
                jsonMap["openTime"] = "\(openTime)"
            }
            if !balls.isEmpty {
                var jsonArrayBalls:Array<String> = []
                for oneValueBalls in balls {
                    jsonArrayBalls.append(oneValueBalls)
                }
                jsonMap["balls"] = jsonArrayBalls
            }
            if hasBlueNum {
                jsonMap["blueNum"] = Int(blueNum)
            }
            if hasDetail {
                jsonMap["detail"] = try detail.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.OpenInfo {
            return try Apiproto.OpenInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.OpenInfo {
            return try Apiproto.OpenInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            if (hasId) {
                output += "\(indent) id: \(id.description)\n"
            }
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasIssue {
                output += "\(indent) issue: \(issue) \n"
            }
            if hasNo {
                output += "\(indent) no: \(no) \n"
            }
            if hasOpenTime {
                output += "\(indent) openTime: \(openTime) \n"
            }
            var ballsElementIndex:Int = 0
            for oneValueBalls in balls  {
                output += "\(indent) balls[\(ballsElementIndex)]: \(oneValueBalls)\n"
                ballsElementIndex += 1
            }
            if hasBlueNum {
                output += "\(indent) blueNum: \(blueNum) \n"
            }
            if hasDetail {
                output += "\(indent) detail {\n"
                if let outDescDetail = detail {
                    output += try outDescDetail.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasId {
                     hashCode = (hashCode &* 31) &+ id.hashValue
                }
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasIssue {
                    hashCode = (hashCode &* 31) &+ issue.hashValue
                }
                if hasNo {
                    hashCode = (hashCode &* 31) &+ no.hashValue
                }
                if hasOpenTime {
                    hashCode = (hashCode &* 31) &+ openTime.hashValue
                }
                for oneValueBalls in balls {
                    hashCode = (hashCode &* 31) &+ oneValueBalls.hashValue
                }
                if hasBlueNum {
                    hashCode = (hashCode &* 31) &+ blueNum.hashValue
                }
                if hasDetail {
                    if let hashValuedetail = detail?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedetail
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.OpenInfo"
        }
        override public func className() -> String {
            return "Apiproto.OpenInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.OpenInfo = Apiproto.OpenInfo()
            public func getMessage() -> Apiproto.OpenInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// 彩种类型
                public var type:Apiproto.LotteryType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Apiproto.LotteryType) -> Apiproto.OpenInfo.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Apiproto.OpenInfo.Builder {
                   builderResult.hasType = false
                   builderResult.type = .allType
                   return self
                }
            /// 彩种id
                public var id:Apiproto.LotteryId {
                    get {
                        return builderResult.id
                    }
                    set (value) {
                        builderResult.hasId = true
                        builderResult.id = value
                    }
                }
                public var hasId:Bool{
                    get {
                        return builderResult.hasId
                    }
                }
            @discardableResult
                public func setId(_ value:Apiproto.LotteryId) -> Apiproto.OpenInfo.Builder {
                  self.id = value
                  return self
                }
            @discardableResult
                public func clearId() -> Apiproto.OpenInfo.Builder {
                   builderResult.hasId = false
                   builderResult.id = .allId
                   return self
                }
            /// 彩种名字
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Apiproto.OpenInfo.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Apiproto.OpenInfo.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// 期号
            public var issue:String {
                get {
                    return builderResult.issue
                }
                set (value) {
                    builderResult.hasIssue = true
                    builderResult.issue = value
                }
            }
            public var hasIssue:Bool {
                get {
                    return builderResult.hasIssue
                }
            }
            @discardableResult
            public func setIssue(_ value:String) -> Apiproto.OpenInfo.Builder {
                self.issue = value
                return self
            }
            @discardableResult
            public func clearIssue() -> Apiproto.OpenInfo.Builder{
                builderResult.hasIssue = false
                builderResult.issue = ""
                return self
            }
            /// 当日期号(高频彩使用)
            public var no:Int32 {
                get {
                    return builderResult.no
                }
                set (value) {
                    builderResult.hasNo = true
                    builderResult.no = value
                }
            }
            public var hasNo:Bool {
                get {
                    return builderResult.hasNo
                }
            }
            @discardableResult
            public func setNo(_ value:Int32) -> Apiproto.OpenInfo.Builder {
                self.no = value
                return self
            }
            @discardableResult
            public func clearNo() -> Apiproto.OpenInfo.Builder{
                builderResult.hasNo = false
                builderResult.no = Int32(0)
                return self
            }
            /// 开奖时间
            public var openTime:Int64 {
                get {
                    return builderResult.openTime
                }
                set (value) {
                    builderResult.hasOpenTime = true
                    builderResult.openTime = value
                }
            }
            public var hasOpenTime:Bool {
                get {
                    return builderResult.hasOpenTime
                }
            }
            @discardableResult
            public func setOpenTime(_ value:Int64) -> Apiproto.OpenInfo.Builder {
                self.openTime = value
                return self
            }
            @discardableResult
            public func clearOpenTime() -> Apiproto.OpenInfo.Builder{
                builderResult.hasOpenTime = false
                builderResult.openTime = Int64(0)
                return self
            }
            /// 开奖号码
            public var balls:Array<String> {
                get {
                    return builderResult.balls
                }
                set (array) {
                    builderResult.balls = array
                }
            }
            @discardableResult
            public func setBalls(_ value:Array<String>) -> Apiproto.OpenInfo.Builder {
                self.balls = value
                return self
            }
            @discardableResult
            public func clearBalls() -> Apiproto.OpenInfo.Builder {
                builderResult.balls.removeAll(keepingCapacity: false)
                return self
            }
            /// 蓝球个数
            public var blueNum:Int32 {
                get {
                    return builderResult.blueNum
                }
                set (value) {
                    builderResult.hasBlueNum = true
                    builderResult.blueNum = value
                }
            }
            public var hasBlueNum:Bool {
                get {
                    return builderResult.hasBlueNum
                }
            }
            @discardableResult
            public func setBlueNum(_ value:Int32) -> Apiproto.OpenInfo.Builder {
                self.blueNum = value
                return self
            }
            @discardableResult
            public func clearBlueNum() -> Apiproto.OpenInfo.Builder{
                builderResult.hasBlueNum = false
                builderResult.blueNum = Int32(0)
                return self
            }
            /// 开奖详细
            public var detail:Apiproto.OpenDetail! {
                get {
                    if detailBuilder_ != nil {
                        builderResult.detail = detailBuilder_.getMessage()
                    }
                    return builderResult.detail
                }
                set (value) {
                    builderResult.hasDetail = true
                    builderResult.detail = value
                }
            }
            public var hasDetail:Bool {
                get {
                    return builderResult.hasDetail
                }
            }
            fileprivate var detailBuilder_:Apiproto.OpenDetail.Builder! {
                didSet {
                    builderResult.hasDetail = true
                }
            }
            public func getDetailBuilder() -> Apiproto.OpenDetail.Builder {
                if detailBuilder_ == nil {
                    detailBuilder_ = Apiproto.OpenDetail.Builder()
                    builderResult.detail = detailBuilder_.getMessage()
                    if detail != nil {
                        try! detailBuilder_.mergeFrom(other: detail)
                    }
                }
                return detailBuilder_
            }
            @discardableResult
            public func setDetail(_ value:Apiproto.OpenDetail!) -> Apiproto.OpenInfo.Builder {
                self.detail = value
                return self
            }
            @discardableResult
            public func mergeDetail(value:Apiproto.OpenDetail) throws -> Apiproto.OpenInfo.Builder {
                if builderResult.hasDetail {
                    builderResult.detail = try Apiproto.OpenDetail.builderWithPrototype(prototype:builderResult.detail).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.detail = value
                }
                builderResult.hasDetail = true
                return self
            }
            @discardableResult
            public func clearDetail() -> Apiproto.OpenInfo.Builder {
                detailBuilder_ = nil
                builderResult.hasDetail = false
                builderResult.detail = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.OpenInfo.Builder {
                builderResult = Apiproto.OpenInfo()
                return self
            }
            override public func clone() throws -> Apiproto.OpenInfo.Builder {
                return try Apiproto.OpenInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.OpenInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.OpenInfo {
                let returnMe:Apiproto.OpenInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.OpenInfo) throws -> Apiproto.OpenInfo.Builder {
                if other == Apiproto.OpenInfo() {
                    return self
                }
                if other.hasType {
                    type = other.type
                }
                if other.hasId {
                    id = other.id
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasIssue {
                    issue = other.issue
                }
                if other.hasNo {
                    no = other.no
                }
                if other.hasOpenTime {
                    openTime = other.openTime
                }
                if !other.balls.isEmpty {
                    builderResult.balls += other.balls
                }
                if other.hasBlueNum {
                    blueNum = other.blueNum
                }
                if (other.hasDetail) {
                    try mergeDetail(value: other.detail)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.OpenInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Apiproto.LotteryType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
                        }

                    case 16:
                        let valueIntid = try codedInputStream.readEnum()
                        if let enumsid = Apiproto.LotteryId(rawValue:valueIntid){
                            id = enumsid
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntid))
                        }

                    case 26:
                        name = try codedInputStream.readString()

                    case 34:
                        issue = try codedInputStream.readString()

                    case 40:
                        no = try codedInputStream.readInt32()

                    case 48:
                        openTime = try codedInputStream.readInt64()

                    case 58:
                        balls += [try codedInputStream.readString()]

                    case 64:
                        blueNum = try codedInputStream.readInt32()

                    case 74:
                        let subBuilder:Apiproto.OpenDetail.Builder = Apiproto.OpenDetail.Builder()
                        if hasDetail {
                            try subBuilder.mergeFrom(other: detail)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        detail = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.OpenInfo.Builder {
                let resultDecodedBuilder = Apiproto.OpenInfo.Builder()
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Apiproto.LotteryType.fromString(str: jsonValueType)
                }
                if let jsonValueId = jsonMap["id"] as? String {
                    resultDecodedBuilder.id = try Apiproto.LotteryId.fromString(str: jsonValueId)
                }
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueIssue = jsonMap["issue"] as? String {
                    resultDecodedBuilder.issue = jsonValueIssue
                }
                if let jsonValueNo = jsonMap["no"] as? Int {
                    resultDecodedBuilder.no = Int32(jsonValueNo)
                } else if let jsonValueNo = jsonMap["no"] as? String {
                    resultDecodedBuilder.no = Int32(jsonValueNo)!
                }
                if let jsonValueOpenTime = jsonMap["openTime"] as? String {
                    resultDecodedBuilder.openTime = Int64(jsonValueOpenTime)!
                } else if let jsonValueOpenTime = jsonMap["openTime"] as? Int {
                    resultDecodedBuilder.openTime = Int64(jsonValueOpenTime)
                }
                if let jsonValueBalls = jsonMap["balls"] as? Array<String> {
                    var jsonArrayBalls:Array<String> = []
                    for oneValueBalls in jsonValueBalls {
                        jsonArrayBalls.append(oneValueBalls)
                    }
                    resultDecodedBuilder.balls = jsonArrayBalls
                }
                if let jsonValueBlueNum = jsonMap["blueNum"] as? Int {
                    resultDecodedBuilder.blueNum = Int32(jsonValueBlueNum)
                } else if let jsonValueBlueNum = jsonMap["blueNum"] as? String {
                    resultDecodedBuilder.blueNum = Int32(jsonValueBlueNum)!
                }
                if let jsonValueDetail = jsonMap["detail"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.detail = try Apiproto.OpenDetail.Builder.decodeToBuilder(jsonMap:jsonValueDetail).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.OpenInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.OpenInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LotteryCollection : GeneratedMessage {

        public static func == (lhs: Apiproto.LotteryCollection, rhs: Apiproto.LotteryCollection) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var type:Apiproto.LotteryType = Apiproto.LotteryType.allType
        public fileprivate(set) var hasType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:type.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.LotteryCollection.Builder {
            return Apiproto.LotteryCollection.classBuilder() as! Apiproto.LotteryCollection.Builder
        }
        public func getBuilder() -> Apiproto.LotteryCollection.Builder {
            return classBuilder() as! Apiproto.LotteryCollection.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.LotteryCollection.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.LotteryCollection.Builder()
        }
        public func toBuilder() throws -> Apiproto.LotteryCollection.Builder {
            return try Apiproto.LotteryCollection.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.LotteryCollection) throws -> Apiproto.LotteryCollection.Builder {
            return try Apiproto.LotteryCollection.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasType {
                jsonMap["type"] = type.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.LotteryCollection {
            return try Apiproto.LotteryCollection.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.LotteryCollection {
            return try Apiproto.LotteryCollection.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.LotteryCollection"
        }
        override public func className() -> String {
            return "Apiproto.LotteryCollection"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.LotteryCollection = Apiproto.LotteryCollection()
            public func getMessage() -> Apiproto.LotteryCollection {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Apiproto.LotteryCollection.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Apiproto.LotteryCollection.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
                public var type:Apiproto.LotteryType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Apiproto.LotteryType) -> Apiproto.LotteryCollection.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Apiproto.LotteryCollection.Builder {
                   builderResult.hasType = false
                   builderResult.type = .allType
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.LotteryCollection.Builder {
                builderResult = Apiproto.LotteryCollection()
                return self
            }
            override public func clone() throws -> Apiproto.LotteryCollection.Builder {
                return try Apiproto.LotteryCollection.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.LotteryCollection {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.LotteryCollection {
                let returnMe:Apiproto.LotteryCollection = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.LotteryCollection) throws -> Apiproto.LotteryCollection.Builder {
                if other == Apiproto.LotteryCollection() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasType {
                    type = other.type
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.LotteryCollection.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LotteryCollection.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 16:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Apiproto.LotteryType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueInttype))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.LotteryCollection.Builder {
                let resultDecodedBuilder = Apiproto.LotteryCollection.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Apiproto.LotteryType.fromString(str: jsonValueType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.LotteryCollection.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.LotteryCollection.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// 最新开奖信息
    final public class LatestOpen : GeneratedMessage {

        public static func == (lhs: Apiproto.LatestOpen, rhs: Apiproto.LatestOpen) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.list == rhs.list)
            fieldCheck = fieldCheck && (lhs.tabs == rhs.tabs)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var list:Array<Apiproto.OpenInfo>  = Array<Apiproto.OpenInfo>()
        public fileprivate(set) var tabs:Array<Apiproto.LotteryCollection>  = Array<Apiproto.LotteryCollection>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementList in list {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementList)
            }
            for oneElementTabs in tabs {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementTabs)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementList in list {
                serialize_size += oneElementList.computeMessageSize(fieldNumber: 1)
            }
            for oneElementTabs in tabs {
                serialize_size += oneElementTabs.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.LatestOpen.Builder {
            return Apiproto.LatestOpen.classBuilder() as! Apiproto.LatestOpen.Builder
        }
        public func getBuilder() -> Apiproto.LatestOpen.Builder {
            return classBuilder() as! Apiproto.LatestOpen.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.LatestOpen.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.LatestOpen.Builder()
        }
        public func toBuilder() throws -> Apiproto.LatestOpen.Builder {
            return try Apiproto.LatestOpen.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.LatestOpen) throws -> Apiproto.LatestOpen.Builder {
            return try Apiproto.LatestOpen.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !list.isEmpty {
                var jsonArrayList:Array<Dictionary<String,Any>> = []
                for oneValueList in list {
                    let ecodedMessageList = try oneValueList.encode()
                    jsonArrayList.append(ecodedMessageList)
                }
                jsonMap["list"] = jsonArrayList
            }
            if !tabs.isEmpty {
                var jsonArrayTabs:Array<Dictionary<String,Any>> = []
                for oneValueTabs in tabs {
                    let ecodedMessageTabs = try oneValueTabs.encode()
                    jsonArrayTabs.append(ecodedMessageTabs)
                }
                jsonMap["tabs"] = jsonArrayTabs
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.LatestOpen {
            return try Apiproto.LatestOpen.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.LatestOpen {
            return try Apiproto.LatestOpen.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var listElementIndex:Int = 0
            for oneElementList in list {
                output += "\(indent) list[\(listElementIndex)] {\n"
                output += try oneElementList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                listElementIndex += 1
            }
            var tabsElementIndex:Int = 0
            for oneElementTabs in tabs {
                output += "\(indent) tabs[\(tabsElementIndex)] {\n"
                output += try oneElementTabs.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                tabsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementList in list {
                    hashCode = (hashCode &* 31) &+ oneElementList.hashValue
                }
                for oneElementTabs in tabs {
                    hashCode = (hashCode &* 31) &+ oneElementTabs.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.LatestOpen"
        }
        override public func className() -> String {
            return "Apiproto.LatestOpen"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.LatestOpen = Apiproto.LatestOpen()
            public func getMessage() -> Apiproto.LatestOpen {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var list:Array<Apiproto.OpenInfo> {
                get {
                    return builderResult.list
                }
                set (value) {
                    builderResult.list = value
                }
            }
            @discardableResult
            public func setList(_ value:Array<Apiproto.OpenInfo>) -> Apiproto.LatestOpen.Builder {
                self.list = value
                return self
            }
            @discardableResult
            public func clearList() -> Apiproto.LatestOpen.Builder {
                builderResult.list.removeAll(keepingCapacity: false)
                return self
            }
            public var tabs:Array<Apiproto.LotteryCollection> {
                get {
                    return builderResult.tabs
                }
                set (value) {
                    builderResult.tabs = value
                }
            }
            @discardableResult
            public func setTabs(_ value:Array<Apiproto.LotteryCollection>) -> Apiproto.LatestOpen.Builder {
                self.tabs = value
                return self
            }
            @discardableResult
            public func clearTabs() -> Apiproto.LatestOpen.Builder {
                builderResult.tabs.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.LatestOpen.Builder {
                builderResult = Apiproto.LatestOpen()
                return self
            }
            override public func clone() throws -> Apiproto.LatestOpen.Builder {
                return try Apiproto.LatestOpen.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.LatestOpen {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.LatestOpen {
                let returnMe:Apiproto.LatestOpen = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.LatestOpen) throws -> Apiproto.LatestOpen.Builder {
                if other == Apiproto.LatestOpen() {
                    return self
                }
                if !other.list.isEmpty  {
                     builderResult.list += other.list
                }
                if !other.tabs.isEmpty  {
                     builderResult.tabs += other.tabs
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.LatestOpen.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LatestOpen.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Apiproto.OpenInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        list.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Apiproto.LotteryCollection.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        tabs.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.LatestOpen.Builder {
                let resultDecodedBuilder = Apiproto.LatestOpen.Builder()
                if let jsonValueList = jsonMap["list"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayList:Array<Apiproto.OpenInfo> = []
                    for oneValueList in jsonValueList {
                        let messageFromStringList = try Apiproto.OpenInfo.Builder.decodeToBuilder(jsonMap:oneValueList).build()

                        jsonArrayList.append(messageFromStringList)
                    }
                    resultDecodedBuilder.list = jsonArrayList
                }
                if let jsonValueTabs = jsonMap["tabs"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTabs:Array<Apiproto.LotteryCollection> = []
                    for oneValueTabs in jsonValueTabs {
                        let messageFromStringTabs = try Apiproto.LotteryCollection.Builder.decodeToBuilder(jsonMap:oneValueTabs).build()

                        jsonArrayTabs.append(messageFromStringTabs)
                    }
                    resultDecodedBuilder.tabs = jsonArrayTabs
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.LatestOpen.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.LatestOpen.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DayHistory : GeneratedMessage {

        public static func == (lhs: Apiproto.DayHistory, rhs: Apiproto.DayHistory) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasDate == rhs.hasDate) && (!lhs.hasDate || lhs.date == rhs.date)
            fieldCheck = fieldCheck && (lhs.list == rhs.list)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// 今天|昨天|前天
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// yyyy-mm-dd
        public fileprivate(set) var date:String = ""
        public fileprivate(set) var hasDate:Bool = false

        public fileprivate(set) var list:Array<Apiproto.OpenInfo>  = Array<Apiproto.OpenInfo>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasDate {
                try codedOutputStream.writeString(fieldNumber: 2, value:date)
            }
            for oneElementList in list {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasDate {
                serialize_size += date.computeStringSize(fieldNumber: 2)
            }
            for oneElementList in list {
                serialize_size += oneElementList.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.DayHistory.Builder {
            return Apiproto.DayHistory.classBuilder() as! Apiproto.DayHistory.Builder
        }
        public func getBuilder() -> Apiproto.DayHistory.Builder {
            return classBuilder() as! Apiproto.DayHistory.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.DayHistory.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.DayHistory.Builder()
        }
        public func toBuilder() throws -> Apiproto.DayHistory.Builder {
            return try Apiproto.DayHistory.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.DayHistory) throws -> Apiproto.DayHistory.Builder {
            return try Apiproto.DayHistory.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasDate {
                jsonMap["date"] = date
            }
            if !list.isEmpty {
                var jsonArrayList:Array<Dictionary<String,Any>> = []
                for oneValueList in list {
                    let ecodedMessageList = try oneValueList.encode()
                    jsonArrayList.append(ecodedMessageList)
                }
                jsonMap["list"] = jsonArrayList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.DayHistory {
            return try Apiproto.DayHistory.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.DayHistory {
            return try Apiproto.DayHistory.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasDate {
                output += "\(indent) date: \(date) \n"
            }
            var listElementIndex:Int = 0
            for oneElementList in list {
                output += "\(indent) list[\(listElementIndex)] {\n"
                output += try oneElementList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                listElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasDate {
                    hashCode = (hashCode &* 31) &+ date.hashValue
                }
                for oneElementList in list {
                    hashCode = (hashCode &* 31) &+ oneElementList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.DayHistory"
        }
        override public func className() -> String {
            return "Apiproto.DayHistory"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.DayHistory = Apiproto.DayHistory()
            public func getMessage() -> Apiproto.DayHistory {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// 今天|昨天|前天
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Apiproto.DayHistory.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Apiproto.DayHistory.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// yyyy-mm-dd
            public var date:String {
                get {
                    return builderResult.date
                }
                set (value) {
                    builderResult.hasDate = true
                    builderResult.date = value
                }
            }
            public var hasDate:Bool {
                get {
                    return builderResult.hasDate
                }
            }
            @discardableResult
            public func setDate(_ value:String) -> Apiproto.DayHistory.Builder {
                self.date = value
                return self
            }
            @discardableResult
            public func clearDate() -> Apiproto.DayHistory.Builder{
                builderResult.hasDate = false
                builderResult.date = ""
                return self
            }
            /// 开奖历史记录(按时间倒序）
            public var list:Array<Apiproto.OpenInfo> {
                get {
                    return builderResult.list
                }
                set (value) {
                    builderResult.list = value
                }
            }
            @discardableResult
            public func setList(_ value:Array<Apiproto.OpenInfo>) -> Apiproto.DayHistory.Builder {
                self.list = value
                return self
            }
            @discardableResult
            public func clearList() -> Apiproto.DayHistory.Builder {
                builderResult.list.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.DayHistory.Builder {
                builderResult = Apiproto.DayHistory()
                return self
            }
            override public func clone() throws -> Apiproto.DayHistory.Builder {
                return try Apiproto.DayHistory.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.DayHistory {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.DayHistory {
                let returnMe:Apiproto.DayHistory = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.DayHistory) throws -> Apiproto.DayHistory.Builder {
                if other == Apiproto.DayHistory() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasDate {
                    date = other.date
                }
                if !other.list.isEmpty  {
                     builderResult.list += other.list
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.DayHistory.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DayHistory.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        date = try codedInputStream.readString()

                    case 26:
                        let subBuilder = Apiproto.OpenInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        list.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.DayHistory.Builder {
                let resultDecodedBuilder = Apiproto.DayHistory.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueDate = jsonMap["date"] as? String {
                    resultDecodedBuilder.date = jsonValueDate
                }
                if let jsonValueList = jsonMap["list"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayList:Array<Apiproto.OpenInfo> = []
                    for oneValueList in jsonValueList {
                        let messageFromStringList = try Apiproto.OpenInfo.Builder.decodeToBuilder(jsonMap:oneValueList).build()

                        jsonArrayList.append(messageFromStringList)
                    }
                    resultDecodedBuilder.list = jsonArrayList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.DayHistory.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.DayHistory.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class History : GeneratedMessage {

        public static func == (lhs: Apiproto.History, rhs: Apiproto.History) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.days == rhs.days)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var days:Array<Apiproto.DayHistory>  = Array<Apiproto.DayHistory>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementDays in days {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDays)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementDays in days {
                serialize_size += oneElementDays.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.History.Builder {
            return Apiproto.History.classBuilder() as! Apiproto.History.Builder
        }
        public func getBuilder() -> Apiproto.History.Builder {
            return classBuilder() as! Apiproto.History.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.History.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.History.Builder()
        }
        public func toBuilder() throws -> Apiproto.History.Builder {
            return try Apiproto.History.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.History) throws -> Apiproto.History.Builder {
            return try Apiproto.History.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !days.isEmpty {
                var jsonArrayDays:Array<Dictionary<String,Any>> = []
                for oneValueDays in days {
                    let ecodedMessageDays = try oneValueDays.encode()
                    jsonArrayDays.append(ecodedMessageDays)
                }
                jsonMap["days"] = jsonArrayDays
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.History {
            return try Apiproto.History.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.History {
            return try Apiproto.History.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var daysElementIndex:Int = 0
            for oneElementDays in days {
                output += "\(indent) days[\(daysElementIndex)] {\n"
                output += try oneElementDays.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                daysElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementDays in days {
                    hashCode = (hashCode &* 31) &+ oneElementDays.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.History"
        }
        override public func className() -> String {
            return "Apiproto.History"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.History = Apiproto.History()
            public func getMessage() -> Apiproto.History {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var days:Array<Apiproto.DayHistory> {
                get {
                    return builderResult.days
                }
                set (value) {
                    builderResult.days = value
                }
            }
            @discardableResult
            public func setDays(_ value:Array<Apiproto.DayHistory>) -> Apiproto.History.Builder {
                self.days = value
                return self
            }
            @discardableResult
            public func clearDays() -> Apiproto.History.Builder {
                builderResult.days.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.History.Builder {
                builderResult = Apiproto.History()
                return self
            }
            override public func clone() throws -> Apiproto.History.Builder {
                return try Apiproto.History.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.History {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.History {
                let returnMe:Apiproto.History = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.History) throws -> Apiproto.History.Builder {
                if other == Apiproto.History() {
                    return self
                }
                if !other.days.isEmpty  {
                     builderResult.days += other.days
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.History.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.History.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Apiproto.DayHistory.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        days.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.History.Builder {
                let resultDecodedBuilder = Apiproto.History.Builder()
                if let jsonValueDays = jsonMap["days"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDays:Array<Apiproto.DayHistory> = []
                    for oneValueDays in jsonValueDays {
                        let messageFromStringDays = try Apiproto.DayHistory.Builder.decodeToBuilder(jsonMap:oneValueDays).build()

                        jsonArrayDays.append(messageFromStringDays)
                    }
                    resultDecodedBuilder.days = jsonArrayDays
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.History.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.History.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// 开奖信息摘要
    final public class OpenInfoDigest : GeneratedMessage {

        public static func == (lhs: Apiproto.OpenInfoDigest, rhs: Apiproto.OpenInfoDigest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasIssue == rhs.hasIssue) && (!lhs.hasIssue || lhs.issue == rhs.issue)
            fieldCheck = fieldCheck && (lhs.balls == rhs.balls)
            fieldCheck = fieldCheck && (lhs.tryBalls == rhs.tryBalls)
            fieldCheck = fieldCheck && (lhs.hasBlueNum == rhs.hasBlueNum) && (!lhs.hasBlueNum || lhs.blueNum == rhs.blueNum)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var issue:String = ""
        public fileprivate(set) var hasIssue:Bool = false

        public fileprivate(set) var balls:Array<String> = Array<String>()
        public fileprivate(set) var tryBalls:Array<String> = Array<String>()
        public fileprivate(set) var blueNum:Int32 = Int32(0)
        public fileprivate(set) var hasBlueNum:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasIssue {
                try codedOutputStream.writeString(fieldNumber: 1, value:issue)
            }
            if !balls.isEmpty {
                for oneValueballs in balls {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValueballs)
                }
            }
            if !tryBalls.isEmpty {
                for oneValuetryBalls in tryBalls {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValuetryBalls)
                }
            }
            if hasBlueNum {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:blueNum)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasIssue {
                serialize_size += issue.computeStringSize(fieldNumber: 1)
            }
            var dataSizeBalls:Int32 = 0
            for oneValueballs in balls {
                dataSizeBalls += oneValueballs.computeStringSizeNoTag()
            }
            serialize_size += dataSizeBalls
            serialize_size += 1 * Int32(balls.count)
            var dataSizeTryBalls:Int32 = 0
            for oneValuetryBalls in tryBalls {
                dataSizeTryBalls += oneValuetryBalls.computeStringSizeNoTag()
            }
            serialize_size += dataSizeTryBalls
            serialize_size += 1 * Int32(tryBalls.count)
            if hasBlueNum {
                serialize_size += blueNum.computeInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.OpenInfoDigest.Builder {
            return Apiproto.OpenInfoDigest.classBuilder() as! Apiproto.OpenInfoDigest.Builder
        }
        public func getBuilder() -> Apiproto.OpenInfoDigest.Builder {
            return classBuilder() as! Apiproto.OpenInfoDigest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.OpenInfoDigest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.OpenInfoDigest.Builder()
        }
        public func toBuilder() throws -> Apiproto.OpenInfoDigest.Builder {
            return try Apiproto.OpenInfoDigest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.OpenInfoDigest) throws -> Apiproto.OpenInfoDigest.Builder {
            return try Apiproto.OpenInfoDigest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasIssue {
                jsonMap["issue"] = issue
            }
            if !balls.isEmpty {
                var jsonArrayBalls:Array<String> = []
                for oneValueBalls in balls {
                    jsonArrayBalls.append(oneValueBalls)
                }
                jsonMap["balls"] = jsonArrayBalls
            }
            if !tryBalls.isEmpty {
                var jsonArrayTryBalls:Array<String> = []
                for oneValueTryBalls in tryBalls {
                    jsonArrayTryBalls.append(oneValueTryBalls)
                }
                jsonMap["tryBalls"] = jsonArrayTryBalls
            }
            if hasBlueNum {
                jsonMap["blueNum"] = Int(blueNum)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.OpenInfoDigest {
            return try Apiproto.OpenInfoDigest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.OpenInfoDigest {
            return try Apiproto.OpenInfoDigest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasIssue {
                output += "\(indent) issue: \(issue) \n"
            }
            var ballsElementIndex:Int = 0
            for oneValueBalls in balls  {
                output += "\(indent) balls[\(ballsElementIndex)]: \(oneValueBalls)\n"
                ballsElementIndex += 1
            }
            var tryBallsElementIndex:Int = 0
            for oneValueTryBalls in tryBalls  {
                output += "\(indent) tryBalls[\(tryBallsElementIndex)]: \(oneValueTryBalls)\n"
                tryBallsElementIndex += 1
            }
            if hasBlueNum {
                output += "\(indent) blueNum: \(blueNum) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIssue {
                    hashCode = (hashCode &* 31) &+ issue.hashValue
                }
                for oneValueBalls in balls {
                    hashCode = (hashCode &* 31) &+ oneValueBalls.hashValue
                }
                for oneValueTryBalls in tryBalls {
                    hashCode = (hashCode &* 31) &+ oneValueTryBalls.hashValue
                }
                if hasBlueNum {
                    hashCode = (hashCode &* 31) &+ blueNum.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.OpenInfoDigest"
        }
        override public func className() -> String {
            return "Apiproto.OpenInfoDigest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.OpenInfoDigest = Apiproto.OpenInfoDigest()
            public func getMessage() -> Apiproto.OpenInfoDigest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var issue:String {
                get {
                    return builderResult.issue
                }
                set (value) {
                    builderResult.hasIssue = true
                    builderResult.issue = value
                }
            }
            public var hasIssue:Bool {
                get {
                    return builderResult.hasIssue
                }
            }
            @discardableResult
            public func setIssue(_ value:String) -> Apiproto.OpenInfoDigest.Builder {
                self.issue = value
                return self
            }
            @discardableResult
            public func clearIssue() -> Apiproto.OpenInfoDigest.Builder{
                builderResult.hasIssue = false
                builderResult.issue = ""
                return self
            }
            public var balls:Array<String> {
                get {
                    return builderResult.balls
                }
                set (array) {
                    builderResult.balls = array
                }
            }
            @discardableResult
            public func setBalls(_ value:Array<String>) -> Apiproto.OpenInfoDigest.Builder {
                self.balls = value
                return self
            }
            @discardableResult
            public func clearBalls() -> Apiproto.OpenInfoDigest.Builder {
                builderResult.balls.removeAll(keepingCapacity: false)
                return self
            }
            public var tryBalls:Array<String> {
                get {
                    return builderResult.tryBalls
                }
                set (array) {
                    builderResult.tryBalls = array
                }
            }
            @discardableResult
            public func setTryBalls(_ value:Array<String>) -> Apiproto.OpenInfoDigest.Builder {
                self.tryBalls = value
                return self
            }
            @discardableResult
            public func clearTryBalls() -> Apiproto.OpenInfoDigest.Builder {
                builderResult.tryBalls.removeAll(keepingCapacity: false)
                return self
            }
            public var blueNum:Int32 {
                get {
                    return builderResult.blueNum
                }
                set (value) {
                    builderResult.hasBlueNum = true
                    builderResult.blueNum = value
                }
            }
            public var hasBlueNum:Bool {
                get {
                    return builderResult.hasBlueNum
                }
            }
            @discardableResult
            public func setBlueNum(_ value:Int32) -> Apiproto.OpenInfoDigest.Builder {
                self.blueNum = value
                return self
            }
            @discardableResult
            public func clearBlueNum() -> Apiproto.OpenInfoDigest.Builder{
                builderResult.hasBlueNum = false
                builderResult.blueNum = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.OpenInfoDigest.Builder {
                builderResult = Apiproto.OpenInfoDigest()
                return self
            }
            override public func clone() throws -> Apiproto.OpenInfoDigest.Builder {
                return try Apiproto.OpenInfoDigest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.OpenInfoDigest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.OpenInfoDigest {
                let returnMe:Apiproto.OpenInfoDigest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.OpenInfoDigest) throws -> Apiproto.OpenInfoDigest.Builder {
                if other == Apiproto.OpenInfoDigest() {
                    return self
                }
                if other.hasIssue {
                    issue = other.issue
                }
                if !other.balls.isEmpty {
                    builderResult.balls += other.balls
                }
                if !other.tryBalls.isEmpty {
                    builderResult.tryBalls += other.tryBalls
                }
                if other.hasBlueNum {
                    blueNum = other.blueNum
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.OpenInfoDigest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfoDigest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        issue = try codedInputStream.readString()

                    case 18:
                        balls += [try codedInputStream.readString()]

                    case 26:
                        tryBalls += [try codedInputStream.readString()]

                    case 32:
                        blueNum = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.OpenInfoDigest.Builder {
                let resultDecodedBuilder = Apiproto.OpenInfoDigest.Builder()
                if let jsonValueIssue = jsonMap["issue"] as? String {
                    resultDecodedBuilder.issue = jsonValueIssue
                }
                if let jsonValueBalls = jsonMap["balls"] as? Array<String> {
                    var jsonArrayBalls:Array<String> = []
                    for oneValueBalls in jsonValueBalls {
                        jsonArrayBalls.append(oneValueBalls)
                    }
                    resultDecodedBuilder.balls = jsonArrayBalls
                }
                if let jsonValueTryBalls = jsonMap["tryBalls"] as? Array<String> {
                    var jsonArrayTryBalls:Array<String> = []
                    for oneValueTryBalls in jsonValueTryBalls {
                        jsonArrayTryBalls.append(oneValueTryBalls)
                    }
                    resultDecodedBuilder.tryBalls = jsonArrayTryBalls
                }
                if let jsonValueBlueNum = jsonMap["blueNum"] as? Int {
                    resultDecodedBuilder.blueNum = Int32(jsonValueBlueNum)
                } else if let jsonValueBlueNum = jsonMap["blueNum"] as? String {
                    resultDecodedBuilder.blueNum = Int32(jsonValueBlueNum)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.OpenInfoDigest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.OpenInfoDigest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DigestHistory : GeneratedMessage {

        public static func == (lhs: Apiproto.DigestHistory, rhs: Apiproto.DigestHistory) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.list == rhs.list)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var list:Array<Apiproto.OpenInfoDigest>  = Array<Apiproto.OpenInfoDigest>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementList in list {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementList in list {
                serialize_size += oneElementList.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.DigestHistory.Builder {
            return Apiproto.DigestHistory.classBuilder() as! Apiproto.DigestHistory.Builder
        }
        public func getBuilder() -> Apiproto.DigestHistory.Builder {
            return classBuilder() as! Apiproto.DigestHistory.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.DigestHistory.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.DigestHistory.Builder()
        }
        public func toBuilder() throws -> Apiproto.DigestHistory.Builder {
            return try Apiproto.DigestHistory.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.DigestHistory) throws -> Apiproto.DigestHistory.Builder {
            return try Apiproto.DigestHistory.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !list.isEmpty {
                var jsonArrayList:Array<Dictionary<String,Any>> = []
                for oneValueList in list {
                    let ecodedMessageList = try oneValueList.encode()
                    jsonArrayList.append(ecodedMessageList)
                }
                jsonMap["list"] = jsonArrayList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.DigestHistory {
            return try Apiproto.DigestHistory.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.DigestHistory {
            return try Apiproto.DigestHistory.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var listElementIndex:Int = 0
            for oneElementList in list {
                output += "\(indent) list[\(listElementIndex)] {\n"
                output += try oneElementList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                listElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementList in list {
                    hashCode = (hashCode &* 31) &+ oneElementList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.DigestHistory"
        }
        override public func className() -> String {
            return "Apiproto.DigestHistory"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.DigestHistory = Apiproto.DigestHistory()
            public func getMessage() -> Apiproto.DigestHistory {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var list:Array<Apiproto.OpenInfoDigest> {
                get {
                    return builderResult.list
                }
                set (value) {
                    builderResult.list = value
                }
            }
            @discardableResult
            public func setList(_ value:Array<Apiproto.OpenInfoDigest>) -> Apiproto.DigestHistory.Builder {
                self.list = value
                return self
            }
            @discardableResult
            public func clearList() -> Apiproto.DigestHistory.Builder {
                builderResult.list.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.DigestHistory.Builder {
                builderResult = Apiproto.DigestHistory()
                return self
            }
            override public func clone() throws -> Apiproto.DigestHistory.Builder {
                return try Apiproto.DigestHistory.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.DigestHistory {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.DigestHistory {
                let returnMe:Apiproto.DigestHistory = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.DigestHistory) throws -> Apiproto.DigestHistory.Builder {
                if other == Apiproto.DigestHistory() {
                    return self
                }
                if !other.list.isEmpty  {
                     builderResult.list += other.list
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.DigestHistory.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DigestHistory.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Apiproto.OpenInfoDigest.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        list.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.DigestHistory.Builder {
                let resultDecodedBuilder = Apiproto.DigestHistory.Builder()
                if let jsonValueList = jsonMap["list"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayList:Array<Apiproto.OpenInfoDigest> = []
                    for oneValueList in jsonValueList {
                        let messageFromStringList = try Apiproto.OpenInfoDigest.Builder.decodeToBuilder(jsonMap:oneValueList).build()

                        jsonArrayList.append(messageFromStringList)
                    }
                    resultDecodedBuilder.list = jsonArrayList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.DigestHistory.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.DigestHistory.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Apiproto.BonusDetail: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.BonusDetail> {
        var mergedArray = Array<Apiproto.BonusDetail>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.BonusDetail? {
        return try Apiproto.BonusDetail.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.BonusDetail {
        return try Apiproto.BonusDetail.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.BonusDetail {
        return try Apiproto.BonusDetail.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.BonusDetail {
        return try Apiproto.BonusDetail.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.BonusDetail {
        return try Apiproto.BonusDetail.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.BonusDetail {
        return try Apiproto.BonusDetail.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.BonusDetail {
        return try Apiproto.BonusDetail.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "num": return self.num
        case "money": return self.money
        default: return nil
        }
    }
}
extension Apiproto.BonusDetail.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "num": return self.num
            case "money": return self.money
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "num":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.num = newSubscriptValue
            case "money":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.money = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.OpenDetail: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.OpenDetail> {
        var mergedArray = Array<Apiproto.OpenDetail>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.OpenDetail? {
        return try Apiproto.OpenDetail.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.OpenDetail {
        return try Apiproto.OpenDetail.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenDetail {
        return try Apiproto.OpenDetail.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.OpenDetail {
        return try Apiproto.OpenDetail.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenDetail {
        return try Apiproto.OpenDetail.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.OpenDetail {
        return try Apiproto.OpenDetail.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenDetail {
        return try Apiproto.OpenDetail.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sale": return self.sale
        case "pool": return self.pool
        case "bonusList": return self.bonusList
        default: return nil
        }
    }
}
extension Apiproto.OpenDetail.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sale": return self.sale
            case "pool": return self.pool
            case "bonusList": return self.bonusList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sale":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.sale = newSubscriptValue
            case "pool":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.pool = newSubscriptValue
            case "bonusList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.BonusDetail> else {
                    return
                }
                self.bonusList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.OpenInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.OpenInfo> {
        var mergedArray = Array<Apiproto.OpenInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.OpenInfo? {
        return try Apiproto.OpenInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.OpenInfo {
        return try Apiproto.OpenInfo.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfo {
        return try Apiproto.OpenInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.OpenInfo {
        return try Apiproto.OpenInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfo {
        return try Apiproto.OpenInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.OpenInfo {
        return try Apiproto.OpenInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfo {
        return try Apiproto.OpenInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "id": return self.id
        case "name": return self.name
        case "issue": return self.issue
        case "no": return self.no
        case "openTime": return self.openTime
        case "balls": return self.balls
        case "blueNum": return self.blueNum
        case "detail": return self.detail
        default: return nil
        }
    }
}
extension Apiproto.OpenInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "id": return self.id
            case "name": return self.name
            case "issue": return self.issue
            case "no": return self.no
            case "openTime": return self.openTime
            case "balls": return self.balls
            case "blueNum": return self.blueNum
            case "detail": return self.detail
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.LotteryType else {
                    return
                }
                self.type = newSubscriptValue
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.LotteryId else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "issue":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.issue = newSubscriptValue
            case "no":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.no = newSubscriptValue
            case "openTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.openTime = newSubscriptValue
            case "balls":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.balls = newSubscriptValue
            case "blueNum":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.blueNum = newSubscriptValue
            case "detail":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.OpenDetail else {
                    return
                }
                self.detail = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.LotteryCollection: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.LotteryCollection> {
        var mergedArray = Array<Apiproto.LotteryCollection>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.LotteryCollection? {
        return try Apiproto.LotteryCollection.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.LotteryCollection {
        return try Apiproto.LotteryCollection.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LotteryCollection {
        return try Apiproto.LotteryCollection.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.LotteryCollection {
        return try Apiproto.LotteryCollection.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LotteryCollection {
        return try Apiproto.LotteryCollection.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.LotteryCollection {
        return try Apiproto.LotteryCollection.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LotteryCollection {
        return try Apiproto.LotteryCollection.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "type": return self.type
        default: return nil
        }
    }
}
extension Apiproto.LotteryCollection.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "type": return self.type
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.LotteryType else {
                    return
                }
                self.type = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.LatestOpen: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.LatestOpen> {
        var mergedArray = Array<Apiproto.LatestOpen>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.LatestOpen? {
        return try Apiproto.LatestOpen.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.LatestOpen {
        return try Apiproto.LatestOpen.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LatestOpen {
        return try Apiproto.LatestOpen.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.LatestOpen {
        return try Apiproto.LatestOpen.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LatestOpen {
        return try Apiproto.LatestOpen.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.LatestOpen {
        return try Apiproto.LatestOpen.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.LatestOpen {
        return try Apiproto.LatestOpen.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "list": return self.list
        case "tabs": return self.tabs
        default: return nil
        }
    }
}
extension Apiproto.LatestOpen.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "list": return self.list
            case "tabs": return self.tabs
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "list":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.OpenInfo> else {
                    return
                }
                self.list = newSubscriptValue
            case "tabs":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.LotteryCollection> else {
                    return
                }
                self.tabs = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.DayHistory: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.DayHistory> {
        var mergedArray = Array<Apiproto.DayHistory>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.DayHistory? {
        return try Apiproto.DayHistory.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.DayHistory {
        return try Apiproto.DayHistory.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DayHistory {
        return try Apiproto.DayHistory.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.DayHistory {
        return try Apiproto.DayHistory.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DayHistory {
        return try Apiproto.DayHistory.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.DayHistory {
        return try Apiproto.DayHistory.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DayHistory {
        return try Apiproto.DayHistory.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "date": return self.date
        case "list": return self.list
        default: return nil
        }
    }
}
extension Apiproto.DayHistory.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "date": return self.date
            case "list": return self.list
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "date":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.date = newSubscriptValue
            case "list":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.OpenInfo> else {
                    return
                }
                self.list = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.History: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.History> {
        var mergedArray = Array<Apiproto.History>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.History? {
        return try Apiproto.History.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.History {
        return try Apiproto.History.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.History {
        return try Apiproto.History.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.History {
        return try Apiproto.History.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.History {
        return try Apiproto.History.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.History {
        return try Apiproto.History.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.History {
        return try Apiproto.History.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "days": return self.days
        default: return nil
        }
    }
}
extension Apiproto.History.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "days": return self.days
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "days":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.DayHistory> else {
                    return
                }
                self.days = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.OpenInfoDigest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.OpenInfoDigest> {
        var mergedArray = Array<Apiproto.OpenInfoDigest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.OpenInfoDigest? {
        return try Apiproto.OpenInfoDigest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.OpenInfoDigest {
        return try Apiproto.OpenInfoDigest.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfoDigest {
        return try Apiproto.OpenInfoDigest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.OpenInfoDigest {
        return try Apiproto.OpenInfoDigest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfoDigest {
        return try Apiproto.OpenInfoDigest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.OpenInfoDigest {
        return try Apiproto.OpenInfoDigest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.OpenInfoDigest {
        return try Apiproto.OpenInfoDigest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "issue": return self.issue
        case "balls": return self.balls
        case "tryBalls": return self.tryBalls
        case "blueNum": return self.blueNum
        default: return nil
        }
    }
}
extension Apiproto.OpenInfoDigest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "issue": return self.issue
            case "balls": return self.balls
            case "tryBalls": return self.tryBalls
            case "blueNum": return self.blueNum
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "issue":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.issue = newSubscriptValue
            case "balls":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.balls = newSubscriptValue
            case "tryBalls":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.tryBalls = newSubscriptValue
            case "blueNum":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.blueNum = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.DigestHistory: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.DigestHistory> {
        var mergedArray = Array<Apiproto.DigestHistory>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.DigestHistory? {
        return try Apiproto.DigestHistory.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.DigestHistory {
        return try Apiproto.DigestHistory.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.OpencaiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DigestHistory {
        return try Apiproto.DigestHistory.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.DigestHistory {
        return try Apiproto.DigestHistory.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DigestHistory {
        return try Apiproto.DigestHistory.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.DigestHistory {
        return try Apiproto.DigestHistory.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.DigestHistory {
        return try Apiproto.DigestHistory.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "list": return self.list
        default: return nil
        }
    }
}
extension Apiproto.DigestHistory.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "list": return self.list
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "list":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.OpenInfoDigest> else {
                    return
                }
                self.list = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
