/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "notify.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public extension Apiproto{}

public extension Apiproto {
    public struct NotifyRoot {
        public static let `default` = NotifyRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    public enum NotifyType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        ///公告
        case announce = 0

        ///提醒
        case remind = 1

        ///私信
        case message = 2

        ///全部
        case all = 3
        public func toString() -> String {
            switch self {
            case .announce: return "Announce"
            case .remind: return "Remind"
            case .message: return "Message"
            case .all: return "All"
            }
        }
        public static func fromString(str:String) throws -> Apiproto.NotifyType {
            switch str {
            case "Announce":    return .announce
            case "Remind":    return .remind
            case "Message":    return .message
            case "All":    return .all
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .announce: return ".announce"
            case .remind: return ".remind"
            case .message: return ".message"
            case .all: return ".all"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:NotifyType, rhs:NotifyType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    final public class Notify : GeneratedMessage {

        public static func == (lhs: Apiproto.Notify, rhs: Apiproto.Notify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
            fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasTarget == rhs.hasTarget) && (!lhs.hasTarget || lhs.target == rhs.target)
            fieldCheck = fieldCheck && (lhs.hasTargetType == rhs.hasTargetType) && (!lhs.hasTargetType || lhs.targetType == rhs.targetType)
            fieldCheck = fieldCheck && (lhs.hasAction == rhs.hasAction) && (!lhs.hasAction || lhs.action == rhs.action)
            fieldCheck = fieldCheck && (lhs.hasSender == rhs.hasSender) && (!lhs.hasSender || lhs.sender == rhs.sender)
            fieldCheck = fieldCheck && (lhs.hasCreated == rhs.hasCreated) && (!lhs.hasCreated || lhs.created == rhs.created)
            fieldCheck = fieldCheck && (lhs.hasUpdated == rhs.hasUpdated) && (!lhs.hasUpdated || lhs.updated == rhs.updated)
            fieldCheck = fieldCheck && (lhs.hasContentLength == rhs.hasContentLength) && (!lhs.hasContentLength || lhs.contentLength == rhs.contentLength)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var id:Int64 = Int64(0)
        public fileprivate(set) var hasId:Bool = false

        public fileprivate(set) var content:String = ""
        public fileprivate(set) var hasContent:Bool = false

        public fileprivate(set) var type:Apiproto.NotifyType = Apiproto.NotifyType.announce
        public fileprivate(set) var hasType:Bool = false
        public fileprivate(set) var target:Int64 = Int64(0)
        public fileprivate(set) var hasTarget:Bool = false

        public fileprivate(set) var targetType:String = ""
        public fileprivate(set) var hasTargetType:Bool = false

        public fileprivate(set) var action:String = ""
        public fileprivate(set) var hasAction:Bool = false

        public fileprivate(set) var sender:Int64 = Int64(0)
        public fileprivate(set) var hasSender:Bool = false

        public fileprivate(set) var created:Int64 = Int64(0)
        public fileprivate(set) var hasCreated:Bool = false

        public fileprivate(set) var updated:Int64 = Int64(0)
        public fileprivate(set) var hasUpdated:Bool = false

        public fileprivate(set) var contentLength:Int64 = Int64(0)
        public fileprivate(set) var hasContentLength:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
            }
            if hasContent {
                try codedOutputStream.writeString(fieldNumber: 2, value:content)
            }
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:type.rawValue)
            }
            if hasTarget {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:target)
            }
            if hasTargetType {
                try codedOutputStream.writeString(fieldNumber: 5, value:targetType)
            }
            if hasAction {
                try codedOutputStream.writeString(fieldNumber: 6, value:action)
            }
            if hasSender {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:sender)
            }
            if hasCreated {
                try codedOutputStream.writeInt64(fieldNumber: 8, value:created)
            }
            if hasUpdated {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:updated)
            }
            if hasContentLength {
                try codedOutputStream.writeInt64(fieldNumber: 10, value:contentLength)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasId {
                serialize_size += id.computeInt64Size(fieldNumber: 1)
            }
            if hasContent {
                serialize_size += content.computeStringSize(fieldNumber: 2)
            }
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 3)
            }
            if hasTarget {
                serialize_size += target.computeInt64Size(fieldNumber: 4)
            }
            if hasTargetType {
                serialize_size += targetType.computeStringSize(fieldNumber: 5)
            }
            if hasAction {
                serialize_size += action.computeStringSize(fieldNumber: 6)
            }
            if hasSender {
                serialize_size += sender.computeInt64Size(fieldNumber: 7)
            }
            if hasCreated {
                serialize_size += created.computeInt64Size(fieldNumber: 8)
            }
            if hasUpdated {
                serialize_size += updated.computeInt64Size(fieldNumber: 9)
            }
            if hasContentLength {
                serialize_size += contentLength.computeInt64Size(fieldNumber: 10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.Notify.Builder {
            return Apiproto.Notify.classBuilder() as! Apiproto.Notify.Builder
        }
        public func getBuilder() -> Apiproto.Notify.Builder {
            return classBuilder() as! Apiproto.Notify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.Notify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.Notify.Builder()
        }
        public func toBuilder() throws -> Apiproto.Notify.Builder {
            return try Apiproto.Notify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.Notify) throws -> Apiproto.Notify.Builder {
            return try Apiproto.Notify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasId {
                jsonMap["id"] = "\(id)"
            }
            if hasContent {
                jsonMap["content"] = content
            }
            if hasType {
                jsonMap["type"] = type.toString()
            }
            if hasTarget {
                jsonMap["target"] = "\(target)"
            }
            if hasTargetType {
                jsonMap["targetType"] = targetType
            }
            if hasAction {
                jsonMap["action"] = action
            }
            if hasSender {
                jsonMap["sender"] = "\(sender)"
            }
            if hasCreated {
                jsonMap["created"] = "\(created)"
            }
            if hasUpdated {
                jsonMap["updated"] = "\(updated)"
            }
            if hasContentLength {
                jsonMap["contentLength"] = "\(contentLength)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.Notify {
            return try Apiproto.Notify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.Notify {
            return try Apiproto.Notify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasId {
                output += "\(indent) id: \(id) \n"
            }
            if hasContent {
                output += "\(indent) content: \(content) \n"
            }
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            if hasTarget {
                output += "\(indent) target: \(target) \n"
            }
            if hasTargetType {
                output += "\(indent) targetType: \(targetType) \n"
            }
            if hasAction {
                output += "\(indent) action: \(action) \n"
            }
            if hasSender {
                output += "\(indent) sender: \(sender) \n"
            }
            if hasCreated {
                output += "\(indent) created: \(created) \n"
            }
            if hasUpdated {
                output += "\(indent) updated: \(updated) \n"
            }
            if hasContentLength {
                output += "\(indent) contentLength: \(contentLength) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasId {
                    hashCode = (hashCode &* 31) &+ id.hashValue
                }
                if hasContent {
                    hashCode = (hashCode &* 31) &+ content.hashValue
                }
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasTarget {
                    hashCode = (hashCode &* 31) &+ target.hashValue
                }
                if hasTargetType {
                    hashCode = (hashCode &* 31) &+ targetType.hashValue
                }
                if hasAction {
                    hashCode = (hashCode &* 31) &+ action.hashValue
                }
                if hasSender {
                    hashCode = (hashCode &* 31) &+ sender.hashValue
                }
                if hasCreated {
                    hashCode = (hashCode &* 31) &+ created.hashValue
                }
                if hasUpdated {
                    hashCode = (hashCode &* 31) &+ updated.hashValue
                }
                if hasContentLength {
                    hashCode = (hashCode &* 31) &+ contentLength.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.Notify"
        }
        override public func className() -> String {
            return "Apiproto.Notify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.Notify = Apiproto.Notify()
            public func getMessage() -> Apiproto.Notify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var id:Int64 {
                get {
                    return builderResult.id
                }
                set (value) {
                    builderResult.hasId = true
                    builderResult.id = value
                }
            }
            public var hasId:Bool {
                get {
                    return builderResult.hasId
                }
            }
            @discardableResult
            public func setId(_ value:Int64) -> Apiproto.Notify.Builder {
                self.id = value
                return self
            }
            @discardableResult
            public func clearId() -> Apiproto.Notify.Builder{
                builderResult.hasId = false
                builderResult.id = Int64(0)
                return self
            }
            public var content:String {
                get {
                    return builderResult.content
                }
                set (value) {
                    builderResult.hasContent = true
                    builderResult.content = value
                }
            }
            public var hasContent:Bool {
                get {
                    return builderResult.hasContent
                }
            }
            @discardableResult
            public func setContent(_ value:String) -> Apiproto.Notify.Builder {
                self.content = value
                return self
            }
            @discardableResult
            public func clearContent() -> Apiproto.Notify.Builder{
                builderResult.hasContent = false
                builderResult.content = ""
                return self
            }
                public var type:Apiproto.NotifyType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Apiproto.NotifyType) -> Apiproto.Notify.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Apiproto.Notify.Builder {
                   builderResult.hasType = false
                   builderResult.type = .announce
                   return self
                }
            public var target:Int64 {
                get {
                    return builderResult.target
                }
                set (value) {
                    builderResult.hasTarget = true
                    builderResult.target = value
                }
            }
            public var hasTarget:Bool {
                get {
                    return builderResult.hasTarget
                }
            }
            @discardableResult
            public func setTarget(_ value:Int64) -> Apiproto.Notify.Builder {
                self.target = value
                return self
            }
            @discardableResult
            public func clearTarget() -> Apiproto.Notify.Builder{
                builderResult.hasTarget = false
                builderResult.target = Int64(0)
                return self
            }
            public var targetType:String {
                get {
                    return builderResult.targetType
                }
                set (value) {
                    builderResult.hasTargetType = true
                    builderResult.targetType = value
                }
            }
            public var hasTargetType:Bool {
                get {
                    return builderResult.hasTargetType
                }
            }
            @discardableResult
            public func setTargetType(_ value:String) -> Apiproto.Notify.Builder {
                self.targetType = value
                return self
            }
            @discardableResult
            public func clearTargetType() -> Apiproto.Notify.Builder{
                builderResult.hasTargetType = false
                builderResult.targetType = ""
                return self
            }
            public var action:String {
                get {
                    return builderResult.action
                }
                set (value) {
                    builderResult.hasAction = true
                    builderResult.action = value
                }
            }
            public var hasAction:Bool {
                get {
                    return builderResult.hasAction
                }
            }
            @discardableResult
            public func setAction(_ value:String) -> Apiproto.Notify.Builder {
                self.action = value
                return self
            }
            @discardableResult
            public func clearAction() -> Apiproto.Notify.Builder{
                builderResult.hasAction = false
                builderResult.action = ""
                return self
            }
            public var sender:Int64 {
                get {
                    return builderResult.sender
                }
                set (value) {
                    builderResult.hasSender = true
                    builderResult.sender = value
                }
            }
            public var hasSender:Bool {
                get {
                    return builderResult.hasSender
                }
            }
            @discardableResult
            public func setSender(_ value:Int64) -> Apiproto.Notify.Builder {
                self.sender = value
                return self
            }
            @discardableResult
            public func clearSender() -> Apiproto.Notify.Builder{
                builderResult.hasSender = false
                builderResult.sender = Int64(0)
                return self
            }
            public var created:Int64 {
                get {
                    return builderResult.created
                }
                set (value) {
                    builderResult.hasCreated = true
                    builderResult.created = value
                }
            }
            public var hasCreated:Bool {
                get {
                    return builderResult.hasCreated
                }
            }
            @discardableResult
            public func setCreated(_ value:Int64) -> Apiproto.Notify.Builder {
                self.created = value
                return self
            }
            @discardableResult
            public func clearCreated() -> Apiproto.Notify.Builder{
                builderResult.hasCreated = false
                builderResult.created = Int64(0)
                return self
            }
            public var updated:Int64 {
                get {
                    return builderResult.updated
                }
                set (value) {
                    builderResult.hasUpdated = true
                    builderResult.updated = value
                }
            }
            public var hasUpdated:Bool {
                get {
                    return builderResult.hasUpdated
                }
            }
            @discardableResult
            public func setUpdated(_ value:Int64) -> Apiproto.Notify.Builder {
                self.updated = value
                return self
            }
            @discardableResult
            public func clearUpdated() -> Apiproto.Notify.Builder{
                builderResult.hasUpdated = false
                builderResult.updated = Int64(0)
                return self
            }
            public var contentLength:Int64 {
                get {
                    return builderResult.contentLength
                }
                set (value) {
                    builderResult.hasContentLength = true
                    builderResult.contentLength = value
                }
            }
            public var hasContentLength:Bool {
                get {
                    return builderResult.hasContentLength
                }
            }
            @discardableResult
            public func setContentLength(_ value:Int64) -> Apiproto.Notify.Builder {
                self.contentLength = value
                return self
            }
            @discardableResult
            public func clearContentLength() -> Apiproto.Notify.Builder{
                builderResult.hasContentLength = false
                builderResult.contentLength = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.Notify.Builder {
                builderResult = Apiproto.Notify()
                return self
            }
            override public func clone() throws -> Apiproto.Notify.Builder {
                return try Apiproto.Notify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.Notify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.Notify {
                let returnMe:Apiproto.Notify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.Notify) throws -> Apiproto.Notify.Builder {
                if other == Apiproto.Notify() {
                    return self
                }
                if other.hasId {
                    id = other.id
                }
                if other.hasContent {
                    content = other.content
                }
                if other.hasType {
                    type = other.type
                }
                if other.hasTarget {
                    target = other.target
                }
                if other.hasTargetType {
                    targetType = other.targetType
                }
                if other.hasAction {
                    action = other.action
                }
                if other.hasSender {
                    sender = other.sender
                }
                if other.hasCreated {
                    created = other.created
                }
                if other.hasUpdated {
                    updated = other.updated
                }
                if other.hasContentLength {
                    contentLength = other.contentLength
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.Notify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.Notify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        id = try codedInputStream.readInt64()

                    case 18:
                        content = try codedInputStream.readString()

                    case 24:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Apiproto.NotifyType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueInttype))
                        }

                    case 32:
                        target = try codedInputStream.readInt64()

                    case 42:
                        targetType = try codedInputStream.readString()

                    case 50:
                        action = try codedInputStream.readString()

                    case 56:
                        sender = try codedInputStream.readInt64()

                    case 64:
                        created = try codedInputStream.readInt64()

                    case 72:
                        updated = try codedInputStream.readInt64()

                    case 80:
                        contentLength = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.Notify.Builder {
                let resultDecodedBuilder = Apiproto.Notify.Builder()
                if let jsonValueId = jsonMap["id"] as? String {
                    resultDecodedBuilder.id = Int64(jsonValueId)!
                } else if let jsonValueId = jsonMap["id"] as? Int {
                    resultDecodedBuilder.id = Int64(jsonValueId)
                }
                if let jsonValueContent = jsonMap["content"] as? String {
                    resultDecodedBuilder.content = jsonValueContent
                }
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Apiproto.NotifyType.fromString(str: jsonValueType)
                }
                if let jsonValueTarget = jsonMap["target"] as? String {
                    resultDecodedBuilder.target = Int64(jsonValueTarget)!
                } else if let jsonValueTarget = jsonMap["target"] as? Int {
                    resultDecodedBuilder.target = Int64(jsonValueTarget)
                }
                if let jsonValueTargetType = jsonMap["targetType"] as? String {
                    resultDecodedBuilder.targetType = jsonValueTargetType
                }
                if let jsonValueAction = jsonMap["action"] as? String {
                    resultDecodedBuilder.action = jsonValueAction
                }
                if let jsonValueSender = jsonMap["sender"] as? String {
                    resultDecodedBuilder.sender = Int64(jsonValueSender)!
                } else if let jsonValueSender = jsonMap["sender"] as? Int {
                    resultDecodedBuilder.sender = Int64(jsonValueSender)
                }
                if let jsonValueCreated = jsonMap["created"] as? String {
                    resultDecodedBuilder.created = Int64(jsonValueCreated)!
                } else if let jsonValueCreated = jsonMap["created"] as? Int {
                    resultDecodedBuilder.created = Int64(jsonValueCreated)
                }
                if let jsonValueUpdated = jsonMap["updated"] as? String {
                    resultDecodedBuilder.updated = Int64(jsonValueUpdated)!
                } else if let jsonValueUpdated = jsonMap["updated"] as? Int {
                    resultDecodedBuilder.updated = Int64(jsonValueUpdated)
                }
                if let jsonValueContentLength = jsonMap["contentLength"] as? String {
                    resultDecodedBuilder.contentLength = Int64(jsonValueContentLength)!
                } else if let jsonValueContentLength = jsonMap["contentLength"] as? Int {
                    resultDecodedBuilder.contentLength = Int64(jsonValueContentLength)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.Notify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.Notify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserNotify : GeneratedMessage {

        public static func == (lhs: Apiproto.UserNotify, rhs: Apiproto.UserNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAccount == rhs.hasAccount) && (!lhs.hasAccount || lhs.account == rhs.account)
            fieldCheck = fieldCheck && (lhs.hasNotify == rhs.hasNotify) && (!lhs.hasNotify || lhs.notify == rhs.notify)
            fieldCheck = fieldCheck && (lhs.hasIsRead == rhs.hasIsRead) && (!lhs.hasIsRead || lhs.isRead == rhs.isRead)
            fieldCheck = fieldCheck && (lhs.hasNotifyType == rhs.hasNotifyType) && (!lhs.hasNotifyType || lhs.notifyType == rhs.notifyType)
            fieldCheck = fieldCheck && (lhs.hasCreated == rhs.hasCreated) && (!lhs.hasCreated || lhs.created == rhs.created)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var account:Int64 = Int64(0)
        public fileprivate(set) var hasAccount:Bool = false

        public fileprivate(set) var notify:Int64 = Int64(0)
        public fileprivate(set) var hasNotify:Bool = false

        public fileprivate(set) var isRead:Bool = false
        public fileprivate(set) var hasIsRead:Bool = false

        public fileprivate(set) var notifyType:Apiproto.NotifyType = Apiproto.NotifyType.announce
        public fileprivate(set) var hasNotifyType:Bool = false
        public fileprivate(set) var created:Int64 = Int64(0)
        public fileprivate(set) var hasCreated:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAccount {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:account)
            }
            if hasNotify {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:notify)
            }
            if hasIsRead {
                try codedOutputStream.writeBool(fieldNumber: 3, value:isRead)
            }
            if hasNotifyType {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:notifyType.rawValue)
            }
            if hasCreated {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:created)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAccount {
                serialize_size += account.computeInt64Size(fieldNumber: 1)
            }
            if hasNotify {
                serialize_size += notify.computeInt64Size(fieldNumber: 2)
            }
            if hasIsRead {
                serialize_size += isRead.computeBoolSize(fieldNumber: 3)
            }
            if (hasNotifyType) {
                serialize_size += notifyType.rawValue.computeEnumSize(fieldNumber: 4)
            }
            if hasCreated {
                serialize_size += created.computeInt64Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.UserNotify.Builder {
            return Apiproto.UserNotify.classBuilder() as! Apiproto.UserNotify.Builder
        }
        public func getBuilder() -> Apiproto.UserNotify.Builder {
            return classBuilder() as! Apiproto.UserNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.UserNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.UserNotify.Builder()
        }
        public func toBuilder() throws -> Apiproto.UserNotify.Builder {
            return try Apiproto.UserNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.UserNotify) throws -> Apiproto.UserNotify.Builder {
            return try Apiproto.UserNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAccount {
                jsonMap["account"] = "\(account)"
            }
            if hasNotify {
                jsonMap["notify"] = "\(notify)"
            }
            if hasIsRead {
                jsonMap["isRead"] = isRead
            }
            if hasNotifyType {
                jsonMap["notifyType"] = notifyType.toString()
            }
            if hasCreated {
                jsonMap["created"] = "\(created)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.UserNotify {
            return try Apiproto.UserNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.UserNotify {
            return try Apiproto.UserNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAccount {
                output += "\(indent) account: \(account) \n"
            }
            if hasNotify {
                output += "\(indent) notify: \(notify) \n"
            }
            if hasIsRead {
                output += "\(indent) isRead: \(isRead) \n"
            }
            if (hasNotifyType) {
                output += "\(indent) notifyType: \(notifyType.description)\n"
            }
            if hasCreated {
                output += "\(indent) created: \(created) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAccount {
                    hashCode = (hashCode &* 31) &+ account.hashValue
                }
                if hasNotify {
                    hashCode = (hashCode &* 31) &+ notify.hashValue
                }
                if hasIsRead {
                    hashCode = (hashCode &* 31) &+ isRead.hashValue
                }
                if hasNotifyType {
                     hashCode = (hashCode &* 31) &+ notifyType.hashValue
                }
                if hasCreated {
                    hashCode = (hashCode &* 31) &+ created.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.UserNotify"
        }
        override public func className() -> String {
            return "Apiproto.UserNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.UserNotify = Apiproto.UserNotify()
            public func getMessage() -> Apiproto.UserNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var account:Int64 {
                get {
                    return builderResult.account
                }
                set (value) {
                    builderResult.hasAccount = true
                    builderResult.account = value
                }
            }
            public var hasAccount:Bool {
                get {
                    return builderResult.hasAccount
                }
            }
            @discardableResult
            public func setAccount(_ value:Int64) -> Apiproto.UserNotify.Builder {
                self.account = value
                return self
            }
            @discardableResult
            public func clearAccount() -> Apiproto.UserNotify.Builder{
                builderResult.hasAccount = false
                builderResult.account = Int64(0)
                return self
            }
            public var notify:Int64 {
                get {
                    return builderResult.notify
                }
                set (value) {
                    builderResult.hasNotify = true
                    builderResult.notify = value
                }
            }
            public var hasNotify:Bool {
                get {
                    return builderResult.hasNotify
                }
            }
            @discardableResult
            public func setNotify(_ value:Int64) -> Apiproto.UserNotify.Builder {
                self.notify = value
                return self
            }
            @discardableResult
            public func clearNotify() -> Apiproto.UserNotify.Builder{
                builderResult.hasNotify = false
                builderResult.notify = Int64(0)
                return self
            }
            public var isRead:Bool {
                get {
                    return builderResult.isRead
                }
                set (value) {
                    builderResult.hasIsRead = true
                    builderResult.isRead = value
                }
            }
            public var hasIsRead:Bool {
                get {
                    return builderResult.hasIsRead
                }
            }
            @discardableResult
            public func setIsRead(_ value:Bool) -> Apiproto.UserNotify.Builder {
                self.isRead = value
                return self
            }
            @discardableResult
            public func clearIsRead() -> Apiproto.UserNotify.Builder{
                builderResult.hasIsRead = false
                builderResult.isRead = false
                return self
            }
                public var notifyType:Apiproto.NotifyType {
                    get {
                        return builderResult.notifyType
                    }
                    set (value) {
                        builderResult.hasNotifyType = true
                        builderResult.notifyType = value
                    }
                }
                public var hasNotifyType:Bool{
                    get {
                        return builderResult.hasNotifyType
                    }
                }
            @discardableResult
                public func setNotifyType(_ value:Apiproto.NotifyType) -> Apiproto.UserNotify.Builder {
                  self.notifyType = value
                  return self
                }
            @discardableResult
                public func clearNotifyType() -> Apiproto.UserNotify.Builder {
                   builderResult.hasNotifyType = false
                   builderResult.notifyType = .announce
                   return self
                }
            public var created:Int64 {
                get {
                    return builderResult.created
                }
                set (value) {
                    builderResult.hasCreated = true
                    builderResult.created = value
                }
            }
            public var hasCreated:Bool {
                get {
                    return builderResult.hasCreated
                }
            }
            @discardableResult
            public func setCreated(_ value:Int64) -> Apiproto.UserNotify.Builder {
                self.created = value
                return self
            }
            @discardableResult
            public func clearCreated() -> Apiproto.UserNotify.Builder{
                builderResult.hasCreated = false
                builderResult.created = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.UserNotify.Builder {
                builderResult = Apiproto.UserNotify()
                return self
            }
            override public func clone() throws -> Apiproto.UserNotify.Builder {
                return try Apiproto.UserNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.UserNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.UserNotify {
                let returnMe:Apiproto.UserNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.UserNotify) throws -> Apiproto.UserNotify.Builder {
                if other == Apiproto.UserNotify() {
                    return self
                }
                if other.hasAccount {
                    account = other.account
                }
                if other.hasNotify {
                    notify = other.notify
                }
                if other.hasIsRead {
                    isRead = other.isRead
                }
                if other.hasNotifyType {
                    notifyType = other.notifyType
                }
                if other.hasCreated {
                    created = other.created
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.UserNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        account = try codedInputStream.readInt64()

                    case 16:
                        notify = try codedInputStream.readInt64()

                    case 24:
                        isRead = try codedInputStream.readBool()

                    case 32:
                        let valueIntnotifyType = try codedInputStream.readEnum()
                        if let enumsnotifyType = Apiproto.NotifyType(rawValue:valueIntnotifyType){
                            notifyType = enumsnotifyType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntnotifyType))
                        }

                    case 40:
                        created = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.UserNotify.Builder {
                let resultDecodedBuilder = Apiproto.UserNotify.Builder()
                if let jsonValueAccount = jsonMap["account"] as? String {
                    resultDecodedBuilder.account = Int64(jsonValueAccount)!
                } else if let jsonValueAccount = jsonMap["account"] as? Int {
                    resultDecodedBuilder.account = Int64(jsonValueAccount)
                }
                if let jsonValueNotify = jsonMap["notify"] as? String {
                    resultDecodedBuilder.notify = Int64(jsonValueNotify)!
                } else if let jsonValueNotify = jsonMap["notify"] as? Int {
                    resultDecodedBuilder.notify = Int64(jsonValueNotify)
                }
                if let jsonValueIsRead = jsonMap["isRead"] as? Bool {
                    resultDecodedBuilder.isRead = jsonValueIsRead
                }
                if let jsonValueNotifyType = jsonMap["notifyType"] as? String {
                    resultDecodedBuilder.notifyType = try Apiproto.NotifyType.fromString(str: jsonValueNotifyType)
                }
                if let jsonValueCreated = jsonMap["created"] as? String {
                    resultDecodedBuilder.created = Int64(jsonValueCreated)!
                } else if let jsonValueCreated = jsonMap["created"] as? Int {
                    resultDecodedBuilder.created = Int64(jsonValueCreated)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.UserNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.UserNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class QueryUserNotifyArg : GeneratedMessage {

        public static func == (lhs: Apiproto.QueryUserNotifyArg, rhs: Apiproto.QueryUserNotifyArg) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAccount == rhs.hasAccount) && (!lhs.hasAccount || lhs.account == rhs.account)
            fieldCheck = fieldCheck && (lhs.hasNotifyType == rhs.hasNotifyType) && (!lhs.hasNotifyType || lhs.notifyType == rhs.notifyType)
            fieldCheck = fieldCheck && (lhs.hasPage == rhs.hasPage) && (!lhs.hasPage || lhs.page == rhs.page)
            fieldCheck = fieldCheck && (lhs.hasPageSize == rhs.hasPageSize) && (!lhs.hasPageSize || lhs.pageSize == rhs.pageSize)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var account:Int64 = Int64(0)
        public fileprivate(set) var hasAccount:Bool = false

        public fileprivate(set) var notifyType:Apiproto.NotifyType = Apiproto.NotifyType.announce
        public fileprivate(set) var hasNotifyType:Bool = false
        public fileprivate(set) var page:Int64 = Int64(0)
        public fileprivate(set) var hasPage:Bool = false

        public fileprivate(set) var pageSize:Int64 = Int64(0)
        public fileprivate(set) var hasPageSize:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAccount {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:account)
            }
            if hasNotifyType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:notifyType.rawValue)
            }
            if hasPage {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:page)
            }
            if hasPageSize {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:pageSize)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAccount {
                serialize_size += account.computeInt64Size(fieldNumber: 1)
            }
            if (hasNotifyType) {
                serialize_size += notifyType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasPage {
                serialize_size += page.computeInt64Size(fieldNumber: 3)
            }
            if hasPageSize {
                serialize_size += pageSize.computeInt64Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.QueryUserNotifyArg.Builder {
            return Apiproto.QueryUserNotifyArg.classBuilder() as! Apiproto.QueryUserNotifyArg.Builder
        }
        public func getBuilder() -> Apiproto.QueryUserNotifyArg.Builder {
            return classBuilder() as! Apiproto.QueryUserNotifyArg.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.QueryUserNotifyArg.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.QueryUserNotifyArg.Builder()
        }
        public func toBuilder() throws -> Apiproto.QueryUserNotifyArg.Builder {
            return try Apiproto.QueryUserNotifyArg.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.QueryUserNotifyArg) throws -> Apiproto.QueryUserNotifyArg.Builder {
            return try Apiproto.QueryUserNotifyArg.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAccount {
                jsonMap["account"] = "\(account)"
            }
            if hasNotifyType {
                jsonMap["notifyType"] = notifyType.toString()
            }
            if hasPage {
                jsonMap["page"] = "\(page)"
            }
            if hasPageSize {
                jsonMap["pageSize"] = "\(pageSize)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.QueryUserNotifyArg {
            return try Apiproto.QueryUserNotifyArg.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.QueryUserNotifyArg {
            return try Apiproto.QueryUserNotifyArg.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAccount {
                output += "\(indent) account: \(account) \n"
            }
            if (hasNotifyType) {
                output += "\(indent) notifyType: \(notifyType.description)\n"
            }
            if hasPage {
                output += "\(indent) page: \(page) \n"
            }
            if hasPageSize {
                output += "\(indent) pageSize: \(pageSize) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAccount {
                    hashCode = (hashCode &* 31) &+ account.hashValue
                }
                if hasNotifyType {
                     hashCode = (hashCode &* 31) &+ notifyType.hashValue
                }
                if hasPage {
                    hashCode = (hashCode &* 31) &+ page.hashValue
                }
                if hasPageSize {
                    hashCode = (hashCode &* 31) &+ pageSize.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.QueryUserNotifyArg"
        }
        override public func className() -> String {
            return "Apiproto.QueryUserNotifyArg"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.QueryUserNotifyArg = Apiproto.QueryUserNotifyArg()
            public func getMessage() -> Apiproto.QueryUserNotifyArg {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var account:Int64 {
                get {
                    return builderResult.account
                }
                set (value) {
                    builderResult.hasAccount = true
                    builderResult.account = value
                }
            }
            public var hasAccount:Bool {
                get {
                    return builderResult.hasAccount
                }
            }
            @discardableResult
            public func setAccount(_ value:Int64) -> Apiproto.QueryUserNotifyArg.Builder {
                self.account = value
                return self
            }
            @discardableResult
            public func clearAccount() -> Apiproto.QueryUserNotifyArg.Builder{
                builderResult.hasAccount = false
                builderResult.account = Int64(0)
                return self
            }
                public var notifyType:Apiproto.NotifyType {
                    get {
                        return builderResult.notifyType
                    }
                    set (value) {
                        builderResult.hasNotifyType = true
                        builderResult.notifyType = value
                    }
                }
                public var hasNotifyType:Bool{
                    get {
                        return builderResult.hasNotifyType
                    }
                }
            @discardableResult
                public func setNotifyType(_ value:Apiproto.NotifyType) -> Apiproto.QueryUserNotifyArg.Builder {
                  self.notifyType = value
                  return self
                }
            @discardableResult
                public func clearNotifyType() -> Apiproto.QueryUserNotifyArg.Builder {
                   builderResult.hasNotifyType = false
                   builderResult.notifyType = .announce
                   return self
                }
            public var page:Int64 {
                get {
                    return builderResult.page
                }
                set (value) {
                    builderResult.hasPage = true
                    builderResult.page = value
                }
            }
            public var hasPage:Bool {
                get {
                    return builderResult.hasPage
                }
            }
            @discardableResult
            public func setPage(_ value:Int64) -> Apiproto.QueryUserNotifyArg.Builder {
                self.page = value
                return self
            }
            @discardableResult
            public func clearPage() -> Apiproto.QueryUserNotifyArg.Builder{
                builderResult.hasPage = false
                builderResult.page = Int64(0)
                return self
            }
            public var pageSize:Int64 {
                get {
                    return builderResult.pageSize
                }
                set (value) {
                    builderResult.hasPageSize = true
                    builderResult.pageSize = value
                }
            }
            public var hasPageSize:Bool {
                get {
                    return builderResult.hasPageSize
                }
            }
            @discardableResult
            public func setPageSize(_ value:Int64) -> Apiproto.QueryUserNotifyArg.Builder {
                self.pageSize = value
                return self
            }
            @discardableResult
            public func clearPageSize() -> Apiproto.QueryUserNotifyArg.Builder{
                builderResult.hasPageSize = false
                builderResult.pageSize = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.QueryUserNotifyArg.Builder {
                builderResult = Apiproto.QueryUserNotifyArg()
                return self
            }
            override public func clone() throws -> Apiproto.QueryUserNotifyArg.Builder {
                return try Apiproto.QueryUserNotifyArg.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.QueryUserNotifyArg {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.QueryUserNotifyArg {
                let returnMe:Apiproto.QueryUserNotifyArg = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.QueryUserNotifyArg) throws -> Apiproto.QueryUserNotifyArg.Builder {
                if other == Apiproto.QueryUserNotifyArg() {
                    return self
                }
                if other.hasAccount {
                    account = other.account
                }
                if other.hasNotifyType {
                    notifyType = other.notifyType
                }
                if other.hasPage {
                    page = other.page
                }
                if other.hasPageSize {
                    pageSize = other.pageSize
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.QueryUserNotifyArg.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyArg.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        account = try codedInputStream.readInt64()

                    case 16:
                        let valueIntnotifyType = try codedInputStream.readEnum()
                        if let enumsnotifyType = Apiproto.NotifyType(rawValue:valueIntnotifyType){
                            notifyType = enumsnotifyType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntnotifyType))
                        }

                    case 24:
                        page = try codedInputStream.readInt64()

                    case 32:
                        pageSize = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.QueryUserNotifyArg.Builder {
                let resultDecodedBuilder = Apiproto.QueryUserNotifyArg.Builder()
                if let jsonValueAccount = jsonMap["account"] as? String {
                    resultDecodedBuilder.account = Int64(jsonValueAccount)!
                } else if let jsonValueAccount = jsonMap["account"] as? Int {
                    resultDecodedBuilder.account = Int64(jsonValueAccount)
                }
                if let jsonValueNotifyType = jsonMap["notifyType"] as? String {
                    resultDecodedBuilder.notifyType = try Apiproto.NotifyType.fromString(str: jsonValueNotifyType)
                }
                if let jsonValuePage = jsonMap["page"] as? String {
                    resultDecodedBuilder.page = Int64(jsonValuePage)!
                } else if let jsonValuePage = jsonMap["page"] as? Int {
                    resultDecodedBuilder.page = Int64(jsonValuePage)
                }
                if let jsonValuePageSize = jsonMap["pageSize"] as? String {
                    resultDecodedBuilder.pageSize = Int64(jsonValuePageSize)!
                } else if let jsonValuePageSize = jsonMap["pageSize"] as? Int {
                    resultDecodedBuilder.pageSize = Int64(jsonValuePageSize)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.QueryUserNotifyArg.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.QueryUserNotifyArg.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ReadNotifyArg : GeneratedMessage {

        public static func == (lhs: Apiproto.ReadNotifyArg, rhs: Apiproto.ReadNotifyArg) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNotifyId == rhs.hasNotifyId) && (!lhs.hasNotifyId || lhs.notifyId == rhs.notifyId)
            fieldCheck = fieldCheck && (lhs.hasAccountId == rhs.hasAccountId) && (!lhs.hasAccountId || lhs.accountId == rhs.accountId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var notifyId:Int64 = Int64(0)
        public fileprivate(set) var hasNotifyId:Bool = false

        public fileprivate(set) var accountId:Int64 = Int64(0)
        public fileprivate(set) var hasAccountId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNotifyId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:notifyId)
            }
            if hasAccountId {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:accountId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNotifyId {
                serialize_size += notifyId.computeInt64Size(fieldNumber: 1)
            }
            if hasAccountId {
                serialize_size += accountId.computeInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.ReadNotifyArg.Builder {
            return Apiproto.ReadNotifyArg.classBuilder() as! Apiproto.ReadNotifyArg.Builder
        }
        public func getBuilder() -> Apiproto.ReadNotifyArg.Builder {
            return classBuilder() as! Apiproto.ReadNotifyArg.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.ReadNotifyArg.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.ReadNotifyArg.Builder()
        }
        public func toBuilder() throws -> Apiproto.ReadNotifyArg.Builder {
            return try Apiproto.ReadNotifyArg.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.ReadNotifyArg) throws -> Apiproto.ReadNotifyArg.Builder {
            return try Apiproto.ReadNotifyArg.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNotifyId {
                jsonMap["notifyId"] = "\(notifyId)"
            }
            if hasAccountId {
                jsonMap["accountId"] = "\(accountId)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.ReadNotifyArg {
            return try Apiproto.ReadNotifyArg.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.ReadNotifyArg {
            return try Apiproto.ReadNotifyArg.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNotifyId {
                output += "\(indent) notifyId: \(notifyId) \n"
            }
            if hasAccountId {
                output += "\(indent) accountId: \(accountId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNotifyId {
                    hashCode = (hashCode &* 31) &+ notifyId.hashValue
                }
                if hasAccountId {
                    hashCode = (hashCode &* 31) &+ accountId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.ReadNotifyArg"
        }
        override public func className() -> String {
            return "Apiproto.ReadNotifyArg"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.ReadNotifyArg = Apiproto.ReadNotifyArg()
            public func getMessage() -> Apiproto.ReadNotifyArg {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var notifyId:Int64 {
                get {
                    return builderResult.notifyId
                }
                set (value) {
                    builderResult.hasNotifyId = true
                    builderResult.notifyId = value
                }
            }
            public var hasNotifyId:Bool {
                get {
                    return builderResult.hasNotifyId
                }
            }
            @discardableResult
            public func setNotifyId(_ value:Int64) -> Apiproto.ReadNotifyArg.Builder {
                self.notifyId = value
                return self
            }
            @discardableResult
            public func clearNotifyId() -> Apiproto.ReadNotifyArg.Builder{
                builderResult.hasNotifyId = false
                builderResult.notifyId = Int64(0)
                return self
            }
            public var accountId:Int64 {
                get {
                    return builderResult.accountId
                }
                set (value) {
                    builderResult.hasAccountId = true
                    builderResult.accountId = value
                }
            }
            public var hasAccountId:Bool {
                get {
                    return builderResult.hasAccountId
                }
            }
            @discardableResult
            public func setAccountId(_ value:Int64) -> Apiproto.ReadNotifyArg.Builder {
                self.accountId = value
                return self
            }
            @discardableResult
            public func clearAccountId() -> Apiproto.ReadNotifyArg.Builder{
                builderResult.hasAccountId = false
                builderResult.accountId = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.ReadNotifyArg.Builder {
                builderResult = Apiproto.ReadNotifyArg()
                return self
            }
            override public func clone() throws -> Apiproto.ReadNotifyArg.Builder {
                return try Apiproto.ReadNotifyArg.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.ReadNotifyArg {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.ReadNotifyArg {
                let returnMe:Apiproto.ReadNotifyArg = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.ReadNotifyArg) throws -> Apiproto.ReadNotifyArg.Builder {
                if other == Apiproto.ReadNotifyArg() {
                    return self
                }
                if other.hasNotifyId {
                    notifyId = other.notifyId
                }
                if other.hasAccountId {
                    accountId = other.accountId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.ReadNotifyArg.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ReadNotifyArg.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        notifyId = try codedInputStream.readInt64()

                    case 16:
                        accountId = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.ReadNotifyArg.Builder {
                let resultDecodedBuilder = Apiproto.ReadNotifyArg.Builder()
                if let jsonValueNotifyId = jsonMap["notifyId"] as? String {
                    resultDecodedBuilder.notifyId = Int64(jsonValueNotifyId)!
                } else if let jsonValueNotifyId = jsonMap["notifyId"] as? Int {
                    resultDecodedBuilder.notifyId = Int64(jsonValueNotifyId)
                }
                if let jsonValueAccountId = jsonMap["accountId"] as? String {
                    resultDecodedBuilder.accountId = Int64(jsonValueAccountId)!
                } else if let jsonValueAccountId = jsonMap["accountId"] as? Int {
                    resultDecodedBuilder.accountId = Int64(jsonValueAccountId)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.ReadNotifyArg.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.ReadNotifyArg.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserNotifyInfo : GeneratedMessage {

        public static func == (lhs: Apiproto.UserNotifyInfo, rhs: Apiproto.UserNotifyInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserNotify == rhs.hasUserNotify) && (!lhs.hasUserNotify || lhs.userNotify == rhs.userNotify)
            fieldCheck = fieldCheck && (lhs.hasNotify == rhs.hasNotify) && (!lhs.hasNotify || lhs.notify == rhs.notify)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userNotify:Apiproto.UserNotify!
        public fileprivate(set) var hasUserNotify:Bool = false
        public fileprivate(set) var notify:Apiproto.Notify!
        public fileprivate(set) var hasNotify:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserNotify {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:userNotify)
            }
            if hasNotify {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:notify)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserNotify {
                if let varSizeuserNotify = userNotify?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeuserNotify
                }
            }
            if hasNotify {
                if let varSizenotify = notify?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizenotify
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.UserNotifyInfo.Builder {
            return Apiproto.UserNotifyInfo.classBuilder() as! Apiproto.UserNotifyInfo.Builder
        }
        public func getBuilder() -> Apiproto.UserNotifyInfo.Builder {
            return classBuilder() as! Apiproto.UserNotifyInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.UserNotifyInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.UserNotifyInfo.Builder()
        }
        public func toBuilder() throws -> Apiproto.UserNotifyInfo.Builder {
            return try Apiproto.UserNotifyInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.UserNotifyInfo) throws -> Apiproto.UserNotifyInfo.Builder {
            return try Apiproto.UserNotifyInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserNotify {
                jsonMap["userNotify"] = try userNotify.encode()
            }
            if hasNotify {
                jsonMap["notify"] = try notify.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.UserNotifyInfo {
            return try Apiproto.UserNotifyInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.UserNotifyInfo {
            return try Apiproto.UserNotifyInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserNotify {
                output += "\(indent) userNotify {\n"
                if let outDescUserNotify = userNotify {
                    output += try outDescUserNotify.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasNotify {
                output += "\(indent) notify {\n"
                if let outDescNotify = notify {
                    output += try outDescNotify.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserNotify {
                    if let hashValueuserNotify = userNotify?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuserNotify
                    }
                }
                if hasNotify {
                    if let hashValuenotify = notify?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenotify
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.UserNotifyInfo"
        }
        override public func className() -> String {
            return "Apiproto.UserNotifyInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.UserNotifyInfo = Apiproto.UserNotifyInfo()
            public func getMessage() -> Apiproto.UserNotifyInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userNotify:Apiproto.UserNotify! {
                get {
                    if userNotifyBuilder_ != nil {
                        builderResult.userNotify = userNotifyBuilder_.getMessage()
                    }
                    return builderResult.userNotify
                }
                set (value) {
                    builderResult.hasUserNotify = true
                    builderResult.userNotify = value
                }
            }
            public var hasUserNotify:Bool {
                get {
                    return builderResult.hasUserNotify
                }
            }
            fileprivate var userNotifyBuilder_:Apiproto.UserNotify.Builder! {
                didSet {
                    builderResult.hasUserNotify = true
                }
            }
            public func getUserNotifyBuilder() -> Apiproto.UserNotify.Builder {
                if userNotifyBuilder_ == nil {
                    userNotifyBuilder_ = Apiproto.UserNotify.Builder()
                    builderResult.userNotify = userNotifyBuilder_.getMessage()
                    if userNotify != nil {
                        try! userNotifyBuilder_.mergeFrom(other: userNotify)
                    }
                }
                return userNotifyBuilder_
            }
            @discardableResult
            public func setUserNotify(_ value:Apiproto.UserNotify!) -> Apiproto.UserNotifyInfo.Builder {
                self.userNotify = value
                return self
            }
            @discardableResult
            public func mergeUserNotify(value:Apiproto.UserNotify) throws -> Apiproto.UserNotifyInfo.Builder {
                if builderResult.hasUserNotify {
                    builderResult.userNotify = try Apiproto.UserNotify.builderWithPrototype(prototype:builderResult.userNotify).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.userNotify = value
                }
                builderResult.hasUserNotify = true
                return self
            }
            @discardableResult
            public func clearUserNotify() -> Apiproto.UserNotifyInfo.Builder {
                userNotifyBuilder_ = nil
                builderResult.hasUserNotify = false
                builderResult.userNotify = nil
                return self
            }
            public var notify:Apiproto.Notify! {
                get {
                    if notifyBuilder_ != nil {
                        builderResult.notify = notifyBuilder_.getMessage()
                    }
                    return builderResult.notify
                }
                set (value) {
                    builderResult.hasNotify = true
                    builderResult.notify = value
                }
            }
            public var hasNotify:Bool {
                get {
                    return builderResult.hasNotify
                }
            }
            fileprivate var notifyBuilder_:Apiproto.Notify.Builder! {
                didSet {
                    builderResult.hasNotify = true
                }
            }
            public func getNotifyBuilder() -> Apiproto.Notify.Builder {
                if notifyBuilder_ == nil {
                    notifyBuilder_ = Apiproto.Notify.Builder()
                    builderResult.notify = notifyBuilder_.getMessage()
                    if notify != nil {
                        try! notifyBuilder_.mergeFrom(other: notify)
                    }
                }
                return notifyBuilder_
            }
            @discardableResult
            public func setNotify(_ value:Apiproto.Notify!) -> Apiproto.UserNotifyInfo.Builder {
                self.notify = value
                return self
            }
            @discardableResult
            public func mergeNotify(value:Apiproto.Notify) throws -> Apiproto.UserNotifyInfo.Builder {
                if builderResult.hasNotify {
                    builderResult.notify = try Apiproto.Notify.builderWithPrototype(prototype:builderResult.notify).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.notify = value
                }
                builderResult.hasNotify = true
                return self
            }
            @discardableResult
            public func clearNotify() -> Apiproto.UserNotifyInfo.Builder {
                notifyBuilder_ = nil
                builderResult.hasNotify = false
                builderResult.notify = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.UserNotifyInfo.Builder {
                builderResult = Apiproto.UserNotifyInfo()
                return self
            }
            override public func clone() throws -> Apiproto.UserNotifyInfo.Builder {
                return try Apiproto.UserNotifyInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.UserNotifyInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.UserNotifyInfo {
                let returnMe:Apiproto.UserNotifyInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.UserNotifyInfo) throws -> Apiproto.UserNotifyInfo.Builder {
                if other == Apiproto.UserNotifyInfo() {
                    return self
                }
                if (other.hasUserNotify) {
                    try mergeUserNotify(value: other.userNotify)
                }
                if (other.hasNotify) {
                    try mergeNotify(value: other.notify)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.UserNotifyInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotifyInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Apiproto.UserNotify.Builder = Apiproto.UserNotify.Builder()
                        if hasUserNotify {
                            try subBuilder.mergeFrom(other: userNotify)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        userNotify = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Apiproto.Notify.Builder = Apiproto.Notify.Builder()
                        if hasNotify {
                            try subBuilder.mergeFrom(other: notify)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        notify = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.UserNotifyInfo.Builder {
                let resultDecodedBuilder = Apiproto.UserNotifyInfo.Builder()
                if let jsonValueUserNotify = jsonMap["userNotify"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.userNotify = try Apiproto.UserNotify.Builder.decodeToBuilder(jsonMap:jsonValueUserNotify).build()

                }
                if let jsonValueNotify = jsonMap["notify"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.notify = try Apiproto.Notify.Builder.decodeToBuilder(jsonMap:jsonValueNotify).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.UserNotifyInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.UserNotifyInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class QueryUserNotifyRes : GeneratedMessage {

        public static func == (lhs: Apiproto.QueryUserNotifyRes, rhs: Apiproto.QueryUserNotifyRes) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.list == rhs.list)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var list:Array<Apiproto.UserNotifyInfo>  = Array<Apiproto.UserNotifyInfo>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementList in list {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementList in list {
                serialize_size += oneElementList.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.QueryUserNotifyRes.Builder {
            return Apiproto.QueryUserNotifyRes.classBuilder() as! Apiproto.QueryUserNotifyRes.Builder
        }
        public func getBuilder() -> Apiproto.QueryUserNotifyRes.Builder {
            return classBuilder() as! Apiproto.QueryUserNotifyRes.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.QueryUserNotifyRes.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.QueryUserNotifyRes.Builder()
        }
        public func toBuilder() throws -> Apiproto.QueryUserNotifyRes.Builder {
            return try Apiproto.QueryUserNotifyRes.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.QueryUserNotifyRes) throws -> Apiproto.QueryUserNotifyRes.Builder {
            return try Apiproto.QueryUserNotifyRes.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !list.isEmpty {
                var jsonArrayList:Array<Dictionary<String,Any>> = []
                for oneValueList in list {
                    let ecodedMessageList = try oneValueList.encode()
                    jsonArrayList.append(ecodedMessageList)
                }
                jsonMap["list"] = jsonArrayList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.QueryUserNotifyRes {
            return try Apiproto.QueryUserNotifyRes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.QueryUserNotifyRes {
            return try Apiproto.QueryUserNotifyRes.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var listElementIndex:Int = 0
            for oneElementList in list {
                output += "\(indent) list[\(listElementIndex)] {\n"
                output += try oneElementList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                listElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementList in list {
                    hashCode = (hashCode &* 31) &+ oneElementList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.QueryUserNotifyRes"
        }
        override public func className() -> String {
            return "Apiproto.QueryUserNotifyRes"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.QueryUserNotifyRes = Apiproto.QueryUserNotifyRes()
            public func getMessage() -> Apiproto.QueryUserNotifyRes {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var list:Array<Apiproto.UserNotifyInfo> {
                get {
                    return builderResult.list
                }
                set (value) {
                    builderResult.list = value
                }
            }
            @discardableResult
            public func setList(_ value:Array<Apiproto.UserNotifyInfo>) -> Apiproto.QueryUserNotifyRes.Builder {
                self.list = value
                return self
            }
            @discardableResult
            public func clearList() -> Apiproto.QueryUserNotifyRes.Builder {
                builderResult.list.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.QueryUserNotifyRes.Builder {
                builderResult = Apiproto.QueryUserNotifyRes()
                return self
            }
            override public func clone() throws -> Apiproto.QueryUserNotifyRes.Builder {
                return try Apiproto.QueryUserNotifyRes.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.QueryUserNotifyRes {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.QueryUserNotifyRes {
                let returnMe:Apiproto.QueryUserNotifyRes = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.QueryUserNotifyRes) throws -> Apiproto.QueryUserNotifyRes.Builder {
                if other == Apiproto.QueryUserNotifyRes() {
                    return self
                }
                if !other.list.isEmpty  {
                     builderResult.list += other.list
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.QueryUserNotifyRes.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyRes.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Apiproto.UserNotifyInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        list.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.QueryUserNotifyRes.Builder {
                let resultDecodedBuilder = Apiproto.QueryUserNotifyRes.Builder()
                if let jsonValueList = jsonMap["list"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayList:Array<Apiproto.UserNotifyInfo> = []
                    for oneValueList in jsonValueList {
                        let messageFromStringList = try Apiproto.UserNotifyInfo.Builder.decodeToBuilder(jsonMap:oneValueList).build()

                        jsonArrayList.append(messageFromStringList)
                    }
                    resultDecodedBuilder.list = jsonArrayList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.QueryUserNotifyRes.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.QueryUserNotifyRes.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Apiproto.Notify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.Notify> {
        var mergedArray = Array<Apiproto.Notify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.Notify? {
        return try Apiproto.Notify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.Notify {
        return try Apiproto.Notify.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.NotifyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.Notify {
        return try Apiproto.Notify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.Notify {
        return try Apiproto.Notify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.Notify {
        return try Apiproto.Notify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.Notify {
        return try Apiproto.Notify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.Notify {
        return try Apiproto.Notify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "content": return self.content
        case "type": return self.type
        case "target": return self.target
        case "targetType": return self.targetType
        case "action": return self.action
        case "sender": return self.sender
        case "created": return self.created
        case "updated": return self.updated
        case "contentLength": return self.contentLength
        default: return nil
        }
    }
}
extension Apiproto.Notify.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "content": return self.content
            case "type": return self.type
            case "target": return self.target
            case "targetType": return self.targetType
            case "action": return self.action
            case "sender": return self.sender
            case "created": return self.created
            case "updated": return self.updated
            case "contentLength": return self.contentLength
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "content":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.content = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.NotifyType else {
                    return
                }
                self.type = newSubscriptValue
            case "target":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.target = newSubscriptValue
            case "targetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.targetType = newSubscriptValue
            case "action":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.action = newSubscriptValue
            case "sender":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sender = newSubscriptValue
            case "created":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.created = newSubscriptValue
            case "updated":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.updated = newSubscriptValue
            case "contentLength":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.contentLength = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.UserNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.UserNotify> {
        var mergedArray = Array<Apiproto.UserNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.UserNotify? {
        return try Apiproto.UserNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.UserNotify {
        return try Apiproto.UserNotify.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.NotifyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotify {
        return try Apiproto.UserNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.UserNotify {
        return try Apiproto.UserNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotify {
        return try Apiproto.UserNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.UserNotify {
        return try Apiproto.UserNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotify {
        return try Apiproto.UserNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "account": return self.account
        case "notify": return self.notify
        case "isRead": return self.isRead
        case "notifyType": return self.notifyType
        case "created": return self.created
        default: return nil
        }
    }
}
extension Apiproto.UserNotify.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "account": return self.account
            case "notify": return self.notify
            case "isRead": return self.isRead
            case "notifyType": return self.notifyType
            case "created": return self.created
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "account":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.account = newSubscriptValue
            case "notify":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.notify = newSubscriptValue
            case "isRead":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isRead = newSubscriptValue
            case "notifyType":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.NotifyType else {
                    return
                }
                self.notifyType = newSubscriptValue
            case "created":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.created = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.QueryUserNotifyArg: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.QueryUserNotifyArg> {
        var mergedArray = Array<Apiproto.QueryUserNotifyArg>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.QueryUserNotifyArg? {
        return try Apiproto.QueryUserNotifyArg.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.QueryUserNotifyArg {
        return try Apiproto.QueryUserNotifyArg.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.NotifyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyArg {
        return try Apiproto.QueryUserNotifyArg.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.QueryUserNotifyArg {
        return try Apiproto.QueryUserNotifyArg.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyArg {
        return try Apiproto.QueryUserNotifyArg.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.QueryUserNotifyArg {
        return try Apiproto.QueryUserNotifyArg.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyArg {
        return try Apiproto.QueryUserNotifyArg.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "account": return self.account
        case "notifyType": return self.notifyType
        case "page": return self.page
        case "pageSize": return self.pageSize
        default: return nil
        }
    }
}
extension Apiproto.QueryUserNotifyArg.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "account": return self.account
            case "notifyType": return self.notifyType
            case "page": return self.page
            case "pageSize": return self.pageSize
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "account":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.account = newSubscriptValue
            case "notifyType":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.NotifyType else {
                    return
                }
                self.notifyType = newSubscriptValue
            case "page":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.page = newSubscriptValue
            case "pageSize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.pageSize = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.ReadNotifyArg: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.ReadNotifyArg> {
        var mergedArray = Array<Apiproto.ReadNotifyArg>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.ReadNotifyArg? {
        return try Apiproto.ReadNotifyArg.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.ReadNotifyArg {
        return try Apiproto.ReadNotifyArg.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.NotifyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ReadNotifyArg {
        return try Apiproto.ReadNotifyArg.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.ReadNotifyArg {
        return try Apiproto.ReadNotifyArg.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ReadNotifyArg {
        return try Apiproto.ReadNotifyArg.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.ReadNotifyArg {
        return try Apiproto.ReadNotifyArg.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ReadNotifyArg {
        return try Apiproto.ReadNotifyArg.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "notifyId": return self.notifyId
        case "accountId": return self.accountId
        default: return nil
        }
    }
}
extension Apiproto.ReadNotifyArg.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "notifyId": return self.notifyId
            case "accountId": return self.accountId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "notifyId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.notifyId = newSubscriptValue
            case "accountId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.accountId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.UserNotifyInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.UserNotifyInfo> {
        var mergedArray = Array<Apiproto.UserNotifyInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.UserNotifyInfo? {
        return try Apiproto.UserNotifyInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.UserNotifyInfo {
        return try Apiproto.UserNotifyInfo.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.NotifyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotifyInfo {
        return try Apiproto.UserNotifyInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.UserNotifyInfo {
        return try Apiproto.UserNotifyInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotifyInfo {
        return try Apiproto.UserNotifyInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.UserNotifyInfo {
        return try Apiproto.UserNotifyInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserNotifyInfo {
        return try Apiproto.UserNotifyInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userNotify": return self.userNotify
        case "notify": return self.notify
        default: return nil
        }
    }
}
extension Apiproto.UserNotifyInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userNotify": return self.userNotify
            case "notify": return self.notify
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userNotify":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.UserNotify else {
                    return
                }
                self.userNotify = newSubscriptValue
            case "notify":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.Notify else {
                    return
                }
                self.notify = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.QueryUserNotifyRes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.QueryUserNotifyRes> {
        var mergedArray = Array<Apiproto.QueryUserNotifyRes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.QueryUserNotifyRes? {
        return try Apiproto.QueryUserNotifyRes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.QueryUserNotifyRes {
        return try Apiproto.QueryUserNotifyRes.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.NotifyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyRes {
        return try Apiproto.QueryUserNotifyRes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.QueryUserNotifyRes {
        return try Apiproto.QueryUserNotifyRes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyRes {
        return try Apiproto.QueryUserNotifyRes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.QueryUserNotifyRes {
        return try Apiproto.QueryUserNotifyRes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.QueryUserNotifyRes {
        return try Apiproto.QueryUserNotifyRes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "list": return self.list
        default: return nil
        }
    }
}
extension Apiproto.QueryUserNotifyRes.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "list": return self.list
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "list":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.UserNotifyInfo> else {
                    return
                }
                self.list = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
