/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "gift.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public extension Apiproto{}

public extension Apiproto {
    public struct GiftRoot {
        public static let `default` = GiftRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Apiproto.UserRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class ExchangeRequest : GeneratedMessage {

        public static func == (lhs: Apiproto.ExchangeRequest, rhs: Apiproto.ExchangeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCode == rhs.hasCode) && (!lhs.hasCode || lhs.code == rhs.code)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var code:String = ""
        public fileprivate(set) var hasCode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCode {
                try codedOutputStream.writeString(fieldNumber: 1, value:code)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCode {
                serialize_size += code.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.ExchangeRequest.Builder {
            return Apiproto.ExchangeRequest.classBuilder() as! Apiproto.ExchangeRequest.Builder
        }
        public func getBuilder() -> Apiproto.ExchangeRequest.Builder {
            return classBuilder() as! Apiproto.ExchangeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.ExchangeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.ExchangeRequest.Builder()
        }
        public func toBuilder() throws -> Apiproto.ExchangeRequest.Builder {
            return try Apiproto.ExchangeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.ExchangeRequest) throws -> Apiproto.ExchangeRequest.Builder {
            return try Apiproto.ExchangeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCode {
                jsonMap["code"] = code
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.ExchangeRequest {
            return try Apiproto.ExchangeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.ExchangeRequest {
            return try Apiproto.ExchangeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCode {
                output += "\(indent) code: \(code) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCode {
                    hashCode = (hashCode &* 31) &+ code.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.ExchangeRequest"
        }
        override public func className() -> String {
            return "Apiproto.ExchangeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.ExchangeRequest = Apiproto.ExchangeRequest()
            public func getMessage() -> Apiproto.ExchangeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var code:String {
                get {
                    return builderResult.code
                }
                set (value) {
                    builderResult.hasCode = true
                    builderResult.code = value
                }
            }
            public var hasCode:Bool {
                get {
                    return builderResult.hasCode
                }
            }
            @discardableResult
            public func setCode(_ value:String) -> Apiproto.ExchangeRequest.Builder {
                self.code = value
                return self
            }
            @discardableResult
            public func clearCode() -> Apiproto.ExchangeRequest.Builder{
                builderResult.hasCode = false
                builderResult.code = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.ExchangeRequest.Builder {
                builderResult = Apiproto.ExchangeRequest()
                return self
            }
            override public func clone() throws -> Apiproto.ExchangeRequest.Builder {
                return try Apiproto.ExchangeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.ExchangeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.ExchangeRequest {
                let returnMe:Apiproto.ExchangeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.ExchangeRequest) throws -> Apiproto.ExchangeRequest.Builder {
                if other == Apiproto.ExchangeRequest() {
                    return self
                }
                if other.hasCode {
                    code = other.code
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.ExchangeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        code = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.ExchangeRequest.Builder {
                let resultDecodedBuilder = Apiproto.ExchangeRequest.Builder()
                if let jsonValueCode = jsonMap["code"] as? String {
                    resultDecodedBuilder.code = jsonValueCode
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.ExchangeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.ExchangeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExchangeReply : GeneratedMessage {

        public static func == (lhs: Apiproto.ExchangeReply, rhs: Apiproto.ExchangeReply) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTicketNum == rhs.hasTicketNum) && (!lhs.hasTicketNum || lhs.ticketNum == rhs.ticketNum)
            fieldCheck = fieldCheck && (lhs.hasCredits == rhs.hasCredits) && (!lhs.hasCredits || lhs.credits == rhs.credits)
            fieldCheck = fieldCheck && (lhs.hasUserInfo == rhs.hasUserInfo) && (!lhs.hasUserInfo || lhs.userInfo == rhs.userInfo)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///购彩券数量.
        public fileprivate(set) var ticketNum:Int64 = Int64(0)
        public fileprivate(set) var hasTicketNum:Bool = false

        ///积分数量.
        public fileprivate(set) var credits:Int64 = Int64(0)
        public fileprivate(set) var hasCredits:Bool = false

        public fileprivate(set) var userInfo:Apiproto.UserInfo!
        public fileprivate(set) var hasUserInfo:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTicketNum {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:ticketNum)
            }
            if hasCredits {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:credits)
            }
            if hasUserInfo {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:userInfo)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTicketNum {
                serialize_size += ticketNum.computeInt64Size(fieldNumber: 1)
            }
            if hasCredits {
                serialize_size += credits.computeInt64Size(fieldNumber: 2)
            }
            if hasUserInfo {
                if let varSizeuserInfo = userInfo?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeuserInfo
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.ExchangeReply.Builder {
            return Apiproto.ExchangeReply.classBuilder() as! Apiproto.ExchangeReply.Builder
        }
        public func getBuilder() -> Apiproto.ExchangeReply.Builder {
            return classBuilder() as! Apiproto.ExchangeReply.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.ExchangeReply.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.ExchangeReply.Builder()
        }
        public func toBuilder() throws -> Apiproto.ExchangeReply.Builder {
            return try Apiproto.ExchangeReply.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.ExchangeReply) throws -> Apiproto.ExchangeReply.Builder {
            return try Apiproto.ExchangeReply.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTicketNum {
                jsonMap["ticketNum"] = "\(ticketNum)"
            }
            if hasCredits {
                jsonMap["credits"] = "\(credits)"
            }
            if hasUserInfo {
                jsonMap["userInfo"] = try userInfo.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.ExchangeReply {
            return try Apiproto.ExchangeReply.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.ExchangeReply {
            return try Apiproto.ExchangeReply.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTicketNum {
                output += "\(indent) ticketNum: \(ticketNum) \n"
            }
            if hasCredits {
                output += "\(indent) credits: \(credits) \n"
            }
            if hasUserInfo {
                output += "\(indent) userInfo {\n"
                if let outDescUserInfo = userInfo {
                    output += try outDescUserInfo.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTicketNum {
                    hashCode = (hashCode &* 31) &+ ticketNum.hashValue
                }
                if hasCredits {
                    hashCode = (hashCode &* 31) &+ credits.hashValue
                }
                if hasUserInfo {
                    if let hashValueuserInfo = userInfo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuserInfo
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.ExchangeReply"
        }
        override public func className() -> String {
            return "Apiproto.ExchangeReply"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.ExchangeReply = Apiproto.ExchangeReply()
            public func getMessage() -> Apiproto.ExchangeReply {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///购彩券数量.
            public var ticketNum:Int64 {
                get {
                    return builderResult.ticketNum
                }
                set (value) {
                    builderResult.hasTicketNum = true
                    builderResult.ticketNum = value
                }
            }
            public var hasTicketNum:Bool {
                get {
                    return builderResult.hasTicketNum
                }
            }
            @discardableResult
            public func setTicketNum(_ value:Int64) -> Apiproto.ExchangeReply.Builder {
                self.ticketNum = value
                return self
            }
            @discardableResult
            public func clearTicketNum() -> Apiproto.ExchangeReply.Builder{
                builderResult.hasTicketNum = false
                builderResult.ticketNum = Int64(0)
                return self
            }
            ///积分数量.
            public var credits:Int64 {
                get {
                    return builderResult.credits
                }
                set (value) {
                    builderResult.hasCredits = true
                    builderResult.credits = value
                }
            }
            public var hasCredits:Bool {
                get {
                    return builderResult.hasCredits
                }
            }
            @discardableResult
            public func setCredits(_ value:Int64) -> Apiproto.ExchangeReply.Builder {
                self.credits = value
                return self
            }
            @discardableResult
            public func clearCredits() -> Apiproto.ExchangeReply.Builder{
                builderResult.hasCredits = false
                builderResult.credits = Int64(0)
                return self
            }
            ///用户信息
            public var userInfo:Apiproto.UserInfo! {
                get {
                    if userInfoBuilder_ != nil {
                        builderResult.userInfo = userInfoBuilder_.getMessage()
                    }
                    return builderResult.userInfo
                }
                set (value) {
                    builderResult.hasUserInfo = true
                    builderResult.userInfo = value
                }
            }
            public var hasUserInfo:Bool {
                get {
                    return builderResult.hasUserInfo
                }
            }
            fileprivate var userInfoBuilder_:Apiproto.UserInfo.Builder! {
                didSet {
                    builderResult.hasUserInfo = true
                }
            }
            public func getUserInfoBuilder() -> Apiproto.UserInfo.Builder {
                if userInfoBuilder_ == nil {
                    userInfoBuilder_ = Apiproto.UserInfo.Builder()
                    builderResult.userInfo = userInfoBuilder_.getMessage()
                    if userInfo != nil {
                        try! userInfoBuilder_.mergeFrom(other: userInfo)
                    }
                }
                return userInfoBuilder_
            }
            @discardableResult
            public func setUserInfo(_ value:Apiproto.UserInfo!) -> Apiproto.ExchangeReply.Builder {
                self.userInfo = value
                return self
            }
            @discardableResult
            public func mergeUserInfo(value:Apiproto.UserInfo) throws -> Apiproto.ExchangeReply.Builder {
                if builderResult.hasUserInfo {
                    builderResult.userInfo = try Apiproto.UserInfo.builderWithPrototype(prototype:builderResult.userInfo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.userInfo = value
                }
                builderResult.hasUserInfo = true
                return self
            }
            @discardableResult
            public func clearUserInfo() -> Apiproto.ExchangeReply.Builder {
                userInfoBuilder_ = nil
                builderResult.hasUserInfo = false
                builderResult.userInfo = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.ExchangeReply.Builder {
                builderResult = Apiproto.ExchangeReply()
                return self
            }
            override public func clone() throws -> Apiproto.ExchangeReply.Builder {
                return try Apiproto.ExchangeReply.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.ExchangeReply {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.ExchangeReply {
                let returnMe:Apiproto.ExchangeReply = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.ExchangeReply) throws -> Apiproto.ExchangeReply.Builder {
                if other == Apiproto.ExchangeReply() {
                    return self
                }
                if other.hasTicketNum {
                    ticketNum = other.ticketNum
                }
                if other.hasCredits {
                    credits = other.credits
                }
                if (other.hasUserInfo) {
                    try mergeUserInfo(value: other.userInfo)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.ExchangeReply.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeReply.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        ticketNum = try codedInputStream.readInt64()

                    case 16:
                        credits = try codedInputStream.readInt64()

                    case 26:
                        let subBuilder:Apiproto.UserInfo.Builder = Apiproto.UserInfo.Builder()
                        if hasUserInfo {
                            try subBuilder.mergeFrom(other: userInfo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        userInfo = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.ExchangeReply.Builder {
                let resultDecodedBuilder = Apiproto.ExchangeReply.Builder()
                if let jsonValueTicketNum = jsonMap["ticketNum"] as? String {
                    resultDecodedBuilder.ticketNum = Int64(jsonValueTicketNum)!
                } else if let jsonValueTicketNum = jsonMap["ticketNum"] as? Int {
                    resultDecodedBuilder.ticketNum = Int64(jsonValueTicketNum)
                }
                if let jsonValueCredits = jsonMap["credits"] as? String {
                    resultDecodedBuilder.credits = Int64(jsonValueCredits)!
                } else if let jsonValueCredits = jsonMap["credits"] as? Int {
                    resultDecodedBuilder.credits = Int64(jsonValueCredits)
                }
                if let jsonValueUserInfo = jsonMap["userInfo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.userInfo = try Apiproto.UserInfo.Builder.decodeToBuilder(jsonMap:jsonValueUserInfo).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.ExchangeReply.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.ExchangeReply.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserInviteInfoReply : GeneratedMessage {

        public static func == (lhs: Apiproto.UserInviteInfoReply, rhs: Apiproto.UserInviteInfoReply) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasInviteNum == rhs.hasInviteNum) && (!lhs.hasInviteNum || lhs.inviteNum == rhs.inviteNum)
            fieldCheck = fieldCheck && (lhs.hasCredits == rhs.hasCredits) && (!lhs.hasCredits || lhs.credits == rhs.credits)
            fieldCheck = fieldCheck && (lhs.hasTicketsNum == rhs.hasTicketsNum) && (!lhs.hasTicketsNum || lhs.ticketsNum == rhs.ticketsNum)
            fieldCheck = fieldCheck && (lhs.hasTicketsMoney == rhs.hasTicketsMoney) && (!lhs.hasTicketsMoney || lhs.ticketsMoney == rhs.ticketsMoney)
            fieldCheck = fieldCheck && (lhs.hasUserInviteStatus == rhs.hasUserInviteStatus) && (!lhs.hasUserInviteStatus || lhs.userInviteStatus == rhs.userInviteStatus)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var inviteNum:Int64 = Int64(0)
        public fileprivate(set) var hasInviteNum:Bool = false

        public fileprivate(set) var credits:Int64 = Int64(0)
        public fileprivate(set) var hasCredits:Bool = false

        public fileprivate(set) var ticketsNum:Int64 = Int64(0)
        public fileprivate(set) var hasTicketsNum:Bool = false

        public fileprivate(set) var ticketsMoney:Int64 = Int64(0)
        public fileprivate(set) var hasTicketsMoney:Bool = false

        ///true 为已经被邀请，false反之
        public fileprivate(set) var userInviteStatus:Bool = false
        public fileprivate(set) var hasUserInviteStatus:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasInviteNum {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:inviteNum)
            }
            if hasCredits {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:credits)
            }
            if hasTicketsNum {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:ticketsNum)
            }
            if hasTicketsMoney {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:ticketsMoney)
            }
            if hasUserInviteStatus {
                try codedOutputStream.writeBool(fieldNumber: 5, value:userInviteStatus)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasInviteNum {
                serialize_size += inviteNum.computeInt64Size(fieldNumber: 1)
            }
            if hasCredits {
                serialize_size += credits.computeInt64Size(fieldNumber: 2)
            }
            if hasTicketsNum {
                serialize_size += ticketsNum.computeInt64Size(fieldNumber: 3)
            }
            if hasTicketsMoney {
                serialize_size += ticketsMoney.computeInt64Size(fieldNumber: 4)
            }
            if hasUserInviteStatus {
                serialize_size += userInviteStatus.computeBoolSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.UserInviteInfoReply.Builder {
            return Apiproto.UserInviteInfoReply.classBuilder() as! Apiproto.UserInviteInfoReply.Builder
        }
        public func getBuilder() -> Apiproto.UserInviteInfoReply.Builder {
            return classBuilder() as! Apiproto.UserInviteInfoReply.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.UserInviteInfoReply.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.UserInviteInfoReply.Builder()
        }
        public func toBuilder() throws -> Apiproto.UserInviteInfoReply.Builder {
            return try Apiproto.UserInviteInfoReply.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.UserInviteInfoReply) throws -> Apiproto.UserInviteInfoReply.Builder {
            return try Apiproto.UserInviteInfoReply.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasInviteNum {
                jsonMap["inviteNum"] = "\(inviteNum)"
            }
            if hasCredits {
                jsonMap["credits"] = "\(credits)"
            }
            if hasTicketsNum {
                jsonMap["ticketsNum"] = "\(ticketsNum)"
            }
            if hasTicketsMoney {
                jsonMap["ticketsMoney"] = "\(ticketsMoney)"
            }
            if hasUserInviteStatus {
                jsonMap["UserInviteStatus"] = userInviteStatus
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.UserInviteInfoReply {
            return try Apiproto.UserInviteInfoReply.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.UserInviteInfoReply {
            return try Apiproto.UserInviteInfoReply.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasInviteNum {
                output += "\(indent) inviteNum: \(inviteNum) \n"
            }
            if hasCredits {
                output += "\(indent) credits: \(credits) \n"
            }
            if hasTicketsNum {
                output += "\(indent) ticketsNum: \(ticketsNum) \n"
            }
            if hasTicketsMoney {
                output += "\(indent) ticketsMoney: \(ticketsMoney) \n"
            }
            if hasUserInviteStatus {
                output += "\(indent) userInviteStatus: \(userInviteStatus) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasInviteNum {
                    hashCode = (hashCode &* 31) &+ inviteNum.hashValue
                }
                if hasCredits {
                    hashCode = (hashCode &* 31) &+ credits.hashValue
                }
                if hasTicketsNum {
                    hashCode = (hashCode &* 31) &+ ticketsNum.hashValue
                }
                if hasTicketsMoney {
                    hashCode = (hashCode &* 31) &+ ticketsMoney.hashValue
                }
                if hasUserInviteStatus {
                    hashCode = (hashCode &* 31) &+ userInviteStatus.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.UserInviteInfoReply"
        }
        override public func className() -> String {
            return "Apiproto.UserInviteInfoReply"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.UserInviteInfoReply = Apiproto.UserInviteInfoReply()
            public func getMessage() -> Apiproto.UserInviteInfoReply {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var inviteNum:Int64 {
                get {
                    return builderResult.inviteNum
                }
                set (value) {
                    builderResult.hasInviteNum = true
                    builderResult.inviteNum = value
                }
            }
            public var hasInviteNum:Bool {
                get {
                    return builderResult.hasInviteNum
                }
            }
            @discardableResult
            public func setInviteNum(_ value:Int64) -> Apiproto.UserInviteInfoReply.Builder {
                self.inviteNum = value
                return self
            }
            @discardableResult
            public func clearInviteNum() -> Apiproto.UserInviteInfoReply.Builder{
                builderResult.hasInviteNum = false
                builderResult.inviteNum = Int64(0)
                return self
            }
            public var credits:Int64 {
                get {
                    return builderResult.credits
                }
                set (value) {
                    builderResult.hasCredits = true
                    builderResult.credits = value
                }
            }
            public var hasCredits:Bool {
                get {
                    return builderResult.hasCredits
                }
            }
            @discardableResult
            public func setCredits(_ value:Int64) -> Apiproto.UserInviteInfoReply.Builder {
                self.credits = value
                return self
            }
            @discardableResult
            public func clearCredits() -> Apiproto.UserInviteInfoReply.Builder{
                builderResult.hasCredits = false
                builderResult.credits = Int64(0)
                return self
            }
            public var ticketsNum:Int64 {
                get {
                    return builderResult.ticketsNum
                }
                set (value) {
                    builderResult.hasTicketsNum = true
                    builderResult.ticketsNum = value
                }
            }
            public var hasTicketsNum:Bool {
                get {
                    return builderResult.hasTicketsNum
                }
            }
            @discardableResult
            public func setTicketsNum(_ value:Int64) -> Apiproto.UserInviteInfoReply.Builder {
                self.ticketsNum = value
                return self
            }
            @discardableResult
            public func clearTicketsNum() -> Apiproto.UserInviteInfoReply.Builder{
                builderResult.hasTicketsNum = false
                builderResult.ticketsNum = Int64(0)
                return self
            }
            public var ticketsMoney:Int64 {
                get {
                    return builderResult.ticketsMoney
                }
                set (value) {
                    builderResult.hasTicketsMoney = true
                    builderResult.ticketsMoney = value
                }
            }
            public var hasTicketsMoney:Bool {
                get {
                    return builderResult.hasTicketsMoney
                }
            }
            @discardableResult
            public func setTicketsMoney(_ value:Int64) -> Apiproto.UserInviteInfoReply.Builder {
                self.ticketsMoney = value
                return self
            }
            @discardableResult
            public func clearTicketsMoney() -> Apiproto.UserInviteInfoReply.Builder{
                builderResult.hasTicketsMoney = false
                builderResult.ticketsMoney = Int64(0)
                return self
            }
            ///true 为已经被邀请，false反之
            public var userInviteStatus:Bool {
                get {
                    return builderResult.userInviteStatus
                }
                set (value) {
                    builderResult.hasUserInviteStatus = true
                    builderResult.userInviteStatus = value
                }
            }
            public var hasUserInviteStatus:Bool {
                get {
                    return builderResult.hasUserInviteStatus
                }
            }
            @discardableResult
            public func setUserInviteStatus(_ value:Bool) -> Apiproto.UserInviteInfoReply.Builder {
                self.userInviteStatus = value
                return self
            }
            @discardableResult
            public func clearUserInviteStatus() -> Apiproto.UserInviteInfoReply.Builder{
                builderResult.hasUserInviteStatus = false
                builderResult.userInviteStatus = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.UserInviteInfoReply.Builder {
                builderResult = Apiproto.UserInviteInfoReply()
                return self
            }
            override public func clone() throws -> Apiproto.UserInviteInfoReply.Builder {
                return try Apiproto.UserInviteInfoReply.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.UserInviteInfoReply {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.UserInviteInfoReply {
                let returnMe:Apiproto.UserInviteInfoReply = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.UserInviteInfoReply) throws -> Apiproto.UserInviteInfoReply.Builder {
                if other == Apiproto.UserInviteInfoReply() {
                    return self
                }
                if other.hasInviteNum {
                    inviteNum = other.inviteNum
                }
                if other.hasCredits {
                    credits = other.credits
                }
                if other.hasTicketsNum {
                    ticketsNum = other.ticketsNum
                }
                if other.hasTicketsMoney {
                    ticketsMoney = other.ticketsMoney
                }
                if other.hasUserInviteStatus {
                    userInviteStatus = other.userInviteStatus
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.UserInviteInfoReply.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserInviteInfoReply.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        inviteNum = try codedInputStream.readInt64()

                    case 16:
                        credits = try codedInputStream.readInt64()

                    case 24:
                        ticketsNum = try codedInputStream.readInt64()

                    case 32:
                        ticketsMoney = try codedInputStream.readInt64()

                    case 40:
                        userInviteStatus = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.UserInviteInfoReply.Builder {
                let resultDecodedBuilder = Apiproto.UserInviteInfoReply.Builder()
                if let jsonValueInviteNum = jsonMap["inviteNum"] as? String {
                    resultDecodedBuilder.inviteNum = Int64(jsonValueInviteNum)!
                } else if let jsonValueInviteNum = jsonMap["inviteNum"] as? Int {
                    resultDecodedBuilder.inviteNum = Int64(jsonValueInviteNum)
                }
                if let jsonValueCredits = jsonMap["credits"] as? String {
                    resultDecodedBuilder.credits = Int64(jsonValueCredits)!
                } else if let jsonValueCredits = jsonMap["credits"] as? Int {
                    resultDecodedBuilder.credits = Int64(jsonValueCredits)
                }
                if let jsonValueTicketsNum = jsonMap["ticketsNum"] as? String {
                    resultDecodedBuilder.ticketsNum = Int64(jsonValueTicketsNum)!
                } else if let jsonValueTicketsNum = jsonMap["ticketsNum"] as? Int {
                    resultDecodedBuilder.ticketsNum = Int64(jsonValueTicketsNum)
                }
                if let jsonValueTicketsMoney = jsonMap["ticketsMoney"] as? String {
                    resultDecodedBuilder.ticketsMoney = Int64(jsonValueTicketsMoney)!
                } else if let jsonValueTicketsMoney = jsonMap["ticketsMoney"] as? Int {
                    resultDecodedBuilder.ticketsMoney = Int64(jsonValueTicketsMoney)
                }
                if let jsonValueUserInviteStatus = jsonMap["UserInviteStatus"] as? Bool {
                    resultDecodedBuilder.userInviteStatus = jsonValueUserInviteStatus
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.UserInviteInfoReply.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.UserInviteInfoReply.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GiftItem : GeneratedMessage {

        public static func == (lhs: Apiproto.GiftItem, rhs: Apiproto.GiftItem) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasDesc == rhs.hasDesc) && (!lhs.hasDesc || lhs.desc == rhs.desc)
            fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// 0: 购彩券
        public fileprivate(set) var type:Int32 = Int32(0)
        public fileprivate(set) var hasType:Bool = false

        public fileprivate(set) var desc:String = ""
        public fileprivate(set) var hasDesc:Bool = false

        public fileprivate(set) var value:Int32 = Int32(0)
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasType {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:type)
            }
            if hasDesc {
                try codedOutputStream.writeString(fieldNumber: 2, value:desc)
            }
            if hasValue {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:value)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasType {
                serialize_size += type.computeInt32Size(fieldNumber: 1)
            }
            if hasDesc {
                serialize_size += desc.computeStringSize(fieldNumber: 2)
            }
            if hasValue {
                serialize_size += value.computeInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.GiftItem.Builder {
            return Apiproto.GiftItem.classBuilder() as! Apiproto.GiftItem.Builder
        }
        public func getBuilder() -> Apiproto.GiftItem.Builder {
            return classBuilder() as! Apiproto.GiftItem.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.GiftItem.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.GiftItem.Builder()
        }
        public func toBuilder() throws -> Apiproto.GiftItem.Builder {
            return try Apiproto.GiftItem.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.GiftItem) throws -> Apiproto.GiftItem.Builder {
            return try Apiproto.GiftItem.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasType {
                jsonMap["type"] = Int(type)
            }
            if hasDesc {
                jsonMap["desc"] = desc
            }
            if hasValue {
                jsonMap["value"] = Int(value)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.GiftItem {
            return try Apiproto.GiftItem.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.GiftItem {
            return try Apiproto.GiftItem.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasType {
                output += "\(indent) type: \(type) \n"
            }
            if hasDesc {
                output += "\(indent) desc: \(desc) \n"
            }
            if hasValue {
                output += "\(indent) value: \(value) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasType {
                    hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasDesc {
                    hashCode = (hashCode &* 31) &+ desc.hashValue
                }
                if hasValue {
                    hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.GiftItem"
        }
        override public func className() -> String {
            return "Apiproto.GiftItem"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.GiftItem = Apiproto.GiftItem()
            public func getMessage() -> Apiproto.GiftItem {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// 0: 购彩券
            public var type:Int32 {
                get {
                    return builderResult.type
                }
                set (value) {
                    builderResult.hasType = true
                    builderResult.type = value
                }
            }
            public var hasType:Bool {
                get {
                    return builderResult.hasType
                }
            }
            @discardableResult
            public func setType(_ value:Int32) -> Apiproto.GiftItem.Builder {
                self.type = value
                return self
            }
            @discardableResult
            public func clearType() -> Apiproto.GiftItem.Builder{
                builderResult.hasType = false
                builderResult.type = Int32(0)
                return self
            }
            public var desc:String {
                get {
                    return builderResult.desc
                }
                set (value) {
                    builderResult.hasDesc = true
                    builderResult.desc = value
                }
            }
            public var hasDesc:Bool {
                get {
                    return builderResult.hasDesc
                }
            }
            @discardableResult
            public func setDesc(_ value:String) -> Apiproto.GiftItem.Builder {
                self.desc = value
                return self
            }
            @discardableResult
            public func clearDesc() -> Apiproto.GiftItem.Builder{
                builderResult.hasDesc = false
                builderResult.desc = ""
                return self
            }
            public var value:Int32 {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public var hasValue:Bool {
                get {
                    return builderResult.hasValue
                }
            }
            @discardableResult
            public func setValue(_ value:Int32) -> Apiproto.GiftItem.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Apiproto.GiftItem.Builder{
                builderResult.hasValue = false
                builderResult.value = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.GiftItem.Builder {
                builderResult = Apiproto.GiftItem()
                return self
            }
            override public func clone() throws -> Apiproto.GiftItem.Builder {
                return try Apiproto.GiftItem.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.GiftItem {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.GiftItem {
                let returnMe:Apiproto.GiftItem = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.GiftItem) throws -> Apiproto.GiftItem.Builder {
                if other == Apiproto.GiftItem() {
                    return self
                }
                if other.hasType {
                    type = other.type
                }
                if other.hasDesc {
                    desc = other.desc
                }
                if other.hasValue {
                    value = other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.GiftItem.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.GiftItem.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        type = try codedInputStream.readInt32()

                    case 18:
                        desc = try codedInputStream.readString()

                    case 24:
                        value = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.GiftItem.Builder {
                let resultDecodedBuilder = Apiproto.GiftItem.Builder()
                if let jsonValueType = jsonMap["type"] as? Int {
                    resultDecodedBuilder.type = Int32(jsonValueType)
                } else if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = Int32(jsonValueType)!
                }
                if let jsonValueDesc = jsonMap["desc"] as? String {
                    resultDecodedBuilder.desc = jsonValueDesc
                }
                if let jsonValueValue = jsonMap["value"] as? Int {
                    resultDecodedBuilder.value = Int32(jsonValueValue)
                } else if let jsonValueValue = jsonMap["value"] as? String {
                    resultDecodedBuilder.value = Int32(jsonValueValue)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.GiftItem.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.GiftItem.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RegistGiftPackage : GeneratedMessage {

        public static func == (lhs: Apiproto.RegistGiftPackage, rhs: Apiproto.RegistGiftPackage) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.list == rhs.list)
            fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var list:Array<Apiproto.GiftItem>  = Array<Apiproto.GiftItem>()
        public fileprivate(set) var title:String = ""
        public fileprivate(set) var hasTitle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementList in list {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementList)
            }
            if hasTitle {
                try codedOutputStream.writeString(fieldNumber: 2, value:title)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementList in list {
                serialize_size += oneElementList.computeMessageSize(fieldNumber: 1)
            }
            if hasTitle {
                serialize_size += title.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Apiproto.RegistGiftPackage.Builder {
            return Apiproto.RegistGiftPackage.classBuilder() as! Apiproto.RegistGiftPackage.Builder
        }
        public func getBuilder() -> Apiproto.RegistGiftPackage.Builder {
            return classBuilder() as! Apiproto.RegistGiftPackage.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.RegistGiftPackage.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Apiproto.RegistGiftPackage.Builder()
        }
        public func toBuilder() throws -> Apiproto.RegistGiftPackage.Builder {
            return try Apiproto.RegistGiftPackage.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apiproto.RegistGiftPackage) throws -> Apiproto.RegistGiftPackage.Builder {
            return try Apiproto.RegistGiftPackage.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !list.isEmpty {
                var jsonArrayList:Array<Dictionary<String,Any>> = []
                for oneValueList in list {
                    let ecodedMessageList = try oneValueList.encode()
                    jsonArrayList.append(ecodedMessageList)
                }
                jsonMap["list"] = jsonArrayList
            }
            if hasTitle {
                jsonMap["title"] = title
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apiproto.RegistGiftPackage {
            return try Apiproto.RegistGiftPackage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apiproto.RegistGiftPackage {
            return try Apiproto.RegistGiftPackage.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var listElementIndex:Int = 0
            for oneElementList in list {
                output += "\(indent) list[\(listElementIndex)] {\n"
                output += try oneElementList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                listElementIndex += 1
            }
            if hasTitle {
                output += "\(indent) title: \(title) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementList in list {
                    hashCode = (hashCode &* 31) &+ oneElementList.hashValue
                }
                if hasTitle {
                    hashCode = (hashCode &* 31) &+ title.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apiproto.RegistGiftPackage"
        }
        override public func className() -> String {
            return "Apiproto.RegistGiftPackage"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Apiproto.RegistGiftPackage = Apiproto.RegistGiftPackage()
            public func getMessage() -> Apiproto.RegistGiftPackage {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var list:Array<Apiproto.GiftItem> {
                get {
                    return builderResult.list
                }
                set (value) {
                    builderResult.list = value
                }
            }
            @discardableResult
            public func setList(_ value:Array<Apiproto.GiftItem>) -> Apiproto.RegistGiftPackage.Builder {
                self.list = value
                return self
            }
            @discardableResult
            public func clearList() -> Apiproto.RegistGiftPackage.Builder {
                builderResult.list.removeAll(keepingCapacity: false)
                return self
            }
            public var title:String {
                get {
                    return builderResult.title
                }
                set (value) {
                    builderResult.hasTitle = true
                    builderResult.title = value
                }
            }
            public var hasTitle:Bool {
                get {
                    return builderResult.hasTitle
                }
            }
            @discardableResult
            public func setTitle(_ value:String) -> Apiproto.RegistGiftPackage.Builder {
                self.title = value
                return self
            }
            @discardableResult
            public func clearTitle() -> Apiproto.RegistGiftPackage.Builder{
                builderResult.hasTitle = false
                builderResult.title = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Apiproto.RegistGiftPackage.Builder {
                builderResult = Apiproto.RegistGiftPackage()
                return self
            }
            override public func clone() throws -> Apiproto.RegistGiftPackage.Builder {
                return try Apiproto.RegistGiftPackage.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Apiproto.RegistGiftPackage {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Apiproto.RegistGiftPackage {
                let returnMe:Apiproto.RegistGiftPackage = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Apiproto.RegistGiftPackage) throws -> Apiproto.RegistGiftPackage.Builder {
                if other == Apiproto.RegistGiftPackage() {
                    return self
                }
                if !other.list.isEmpty  {
                     builderResult.list += other.list
                }
                if other.hasTitle {
                    title = other.title
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apiproto.RegistGiftPackage.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.RegistGiftPackage.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Apiproto.GiftItem.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        list.append(subBuilder.buildPartial())

                    case 18:
                        title = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apiproto.RegistGiftPackage.Builder {
                let resultDecodedBuilder = Apiproto.RegistGiftPackage.Builder()
                if let jsonValueList = jsonMap["list"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayList:Array<Apiproto.GiftItem> = []
                    for oneValueList in jsonValueList {
                        let messageFromStringList = try Apiproto.GiftItem.Builder.decodeToBuilder(jsonMap:oneValueList).build()

                        jsonArrayList.append(messageFromStringList)
                    }
                    resultDecodedBuilder.list = jsonArrayList
                }
                if let jsonValueTitle = jsonMap["title"] as? String {
                    resultDecodedBuilder.title = jsonValueTitle
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Apiproto.RegistGiftPackage.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Apiproto.RegistGiftPackage.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Apiproto.ExchangeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.ExchangeRequest> {
        var mergedArray = Array<Apiproto.ExchangeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.ExchangeRequest? {
        return try Apiproto.ExchangeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.ExchangeRequest {
        return try Apiproto.ExchangeRequest.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.GiftRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeRequest {
        return try Apiproto.ExchangeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.ExchangeRequest {
        return try Apiproto.ExchangeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeRequest {
        return try Apiproto.ExchangeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.ExchangeRequest {
        return try Apiproto.ExchangeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeRequest {
        return try Apiproto.ExchangeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "code": return self.code
        default: return nil
        }
    }
}
extension Apiproto.ExchangeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "code": return self.code
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "code":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.code = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.ExchangeReply: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.ExchangeReply> {
        var mergedArray = Array<Apiproto.ExchangeReply>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.ExchangeReply? {
        return try Apiproto.ExchangeReply.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.ExchangeReply {
        return try Apiproto.ExchangeReply.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.GiftRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeReply {
        return try Apiproto.ExchangeReply.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.ExchangeReply {
        return try Apiproto.ExchangeReply.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeReply {
        return try Apiproto.ExchangeReply.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.ExchangeReply {
        return try Apiproto.ExchangeReply.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.ExchangeReply {
        return try Apiproto.ExchangeReply.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "ticketNum": return self.ticketNum
        case "credits": return self.credits
        case "userInfo": return self.userInfo
        default: return nil
        }
    }
}
extension Apiproto.ExchangeReply.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ticketNum": return self.ticketNum
            case "credits": return self.credits
            case "userInfo": return self.userInfo
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ticketNum":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.ticketNum = newSubscriptValue
            case "credits":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.credits = newSubscriptValue
            case "userInfo":
                guard let newSubscriptValue = newSubscriptValue as? Apiproto.UserInfo else {
                    return
                }
                self.userInfo = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.UserInviteInfoReply: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.UserInviteInfoReply> {
        var mergedArray = Array<Apiproto.UserInviteInfoReply>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.UserInviteInfoReply? {
        return try Apiproto.UserInviteInfoReply.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.UserInviteInfoReply {
        return try Apiproto.UserInviteInfoReply.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.GiftRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserInviteInfoReply {
        return try Apiproto.UserInviteInfoReply.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.UserInviteInfoReply {
        return try Apiproto.UserInviteInfoReply.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserInviteInfoReply {
        return try Apiproto.UserInviteInfoReply.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.UserInviteInfoReply {
        return try Apiproto.UserInviteInfoReply.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.UserInviteInfoReply {
        return try Apiproto.UserInviteInfoReply.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "inviteNum": return self.inviteNum
        case "credits": return self.credits
        case "ticketsNum": return self.ticketsNum
        case "ticketsMoney": return self.ticketsMoney
        case "userInviteStatus": return self.userInviteStatus
        default: return nil
        }
    }
}
extension Apiproto.UserInviteInfoReply.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "inviteNum": return self.inviteNum
            case "credits": return self.credits
            case "ticketsNum": return self.ticketsNum
            case "ticketsMoney": return self.ticketsMoney
            case "userInviteStatus": return self.userInviteStatus
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "inviteNum":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.inviteNum = newSubscriptValue
            case "credits":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.credits = newSubscriptValue
            case "ticketsNum":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.ticketsNum = newSubscriptValue
            case "ticketsMoney":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.ticketsMoney = newSubscriptValue
            case "userInviteStatus":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.userInviteStatus = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.GiftItem: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.GiftItem> {
        var mergedArray = Array<Apiproto.GiftItem>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.GiftItem? {
        return try Apiproto.GiftItem.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.GiftItem {
        return try Apiproto.GiftItem.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.GiftRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.GiftItem {
        return try Apiproto.GiftItem.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.GiftItem {
        return try Apiproto.GiftItem.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.GiftItem {
        return try Apiproto.GiftItem.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.GiftItem {
        return try Apiproto.GiftItem.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.GiftItem {
        return try Apiproto.GiftItem.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "desc": return self.desc
        case "value": return self.value
        default: return nil
        }
    }
}
extension Apiproto.GiftItem.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "desc": return self.desc
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.type = newSubscriptValue
            case "desc":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.desc = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Apiproto.RegistGiftPackage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apiproto.RegistGiftPackage> {
        var mergedArray = Array<Apiproto.RegistGiftPackage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apiproto.RegistGiftPackage? {
        return try Apiproto.RegistGiftPackage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Apiproto.RegistGiftPackage {
        return try Apiproto.RegistGiftPackage.Builder().mergeFrom(data: data, extensionRegistry:Apiproto.GiftRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apiproto.RegistGiftPackage {
        return try Apiproto.RegistGiftPackage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Apiproto.RegistGiftPackage {
        return try Apiproto.RegistGiftPackage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.RegistGiftPackage {
        return try Apiproto.RegistGiftPackage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apiproto.RegistGiftPackage {
        return try Apiproto.RegistGiftPackage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apiproto.RegistGiftPackage {
        return try Apiproto.RegistGiftPackage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "list": return self.list
        case "title": return self.title
        default: return nil
        }
    }
}
extension Apiproto.RegistGiftPackage.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "list": return self.list
            case "title": return self.title
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "list":
                guard let newSubscriptValue = newSubscriptValue as? Array<Apiproto.GiftItem> else {
                    return
                }
                self.list = newSubscriptValue
            case "title":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.title = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
